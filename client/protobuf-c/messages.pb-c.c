/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: messages.proto */

/* Do not generate deprecated warnings for self */
#ifndef PROTOBUF_C__NO_DEPRECATED
#define PROTOBUF_C__NO_DEPRECATED
#endif

#include "messages.pb-c.h"
void   initialize__init
                     (Initialize         *message)
{
  static Initialize init_value = INITIALIZE__INIT;
  *message = init_value;
}
size_t initialize__get_packed_size
                     (const Initialize *message)
{
  assert(message->base.descriptor == &initialize__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t initialize__pack
                     (const Initialize *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &initialize__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t initialize__pack_to_buffer
                     (const Initialize *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &initialize__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Initialize *
       initialize__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Initialize *)
     protobuf_c_message_unpack (&initialize__descriptor,
                                allocator, len, data);
}
void   initialize__free_unpacked
                     (Initialize *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &initialize__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   get_features__init
                     (GetFeatures         *message)
{
  static GetFeatures init_value = GET_FEATURES__INIT;
  *message = init_value;
}
size_t get_features__get_packed_size
                     (const GetFeatures *message)
{
  assert(message->base.descriptor == &get_features__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t get_features__pack
                     (const GetFeatures *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &get_features__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t get_features__pack_to_buffer
                     (const GetFeatures *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &get_features__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GetFeatures *
       get_features__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GetFeatures *)
     protobuf_c_message_unpack (&get_features__descriptor,
                                allocator, len, data);
}
void   get_features__free_unpacked
                     (GetFeatures *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &get_features__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   features__init
                     (Features         *message)
{
  static Features init_value = FEATURES__INIT;
  *message = init_value;
}
size_t features__get_packed_size
                     (const Features *message)
{
  assert(message->base.descriptor == &features__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t features__pack
                     (const Features *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &features__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t features__pack_to_buffer
                     (const Features *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &features__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Features *
       features__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Features *)
     protobuf_c_message_unpack (&features__descriptor,
                                allocator, len, data);
}
void   features__free_unpacked
                     (Features *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &features__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   clear_session__init
                     (ClearSession         *message)
{
  static ClearSession init_value = CLEAR_SESSION__INIT;
  *message = init_value;
}
size_t clear_session__get_packed_size
                     (const ClearSession *message)
{
  assert(message->base.descriptor == &clear_session__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t clear_session__pack
                     (const ClearSession *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &clear_session__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t clear_session__pack_to_buffer
                     (const ClearSession *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &clear_session__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
ClearSession *
       clear_session__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (ClearSession *)
     protobuf_c_message_unpack (&clear_session__descriptor,
                                allocator, len, data);
}
void   clear_session__free_unpacked
                     (ClearSession *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &clear_session__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   apply_settings__init
                     (ApplySettings         *message)
{
  static ApplySettings init_value = APPLY_SETTINGS__INIT;
  *message = init_value;
}
size_t apply_settings__get_packed_size
                     (const ApplySettings *message)
{
  assert(message->base.descriptor == &apply_settings__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t apply_settings__pack
                     (const ApplySettings *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &apply_settings__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t apply_settings__pack_to_buffer
                     (const ApplySettings *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &apply_settings__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
ApplySettings *
       apply_settings__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (ApplySettings *)
     protobuf_c_message_unpack (&apply_settings__descriptor,
                                allocator, len, data);
}
void   apply_settings__free_unpacked
                     (ApplySettings *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &apply_settings__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   change_pin__init
                     (ChangePin         *message)
{
  static ChangePin init_value = CHANGE_PIN__INIT;
  *message = init_value;
}
size_t change_pin__get_packed_size
                     (const ChangePin *message)
{
  assert(message->base.descriptor == &change_pin__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t change_pin__pack
                     (const ChangePin *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &change_pin__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t change_pin__pack_to_buffer
                     (const ChangePin *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &change_pin__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
ChangePin *
       change_pin__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (ChangePin *)
     protobuf_c_message_unpack (&change_pin__descriptor,
                                allocator, len, data);
}
void   change_pin__free_unpacked
                     (ChangePin *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &change_pin__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   ping__init
                     (Ping         *message)
{
  static Ping init_value = PING__INIT;
  *message = init_value;
}
size_t ping__get_packed_size
                     (const Ping *message)
{
  assert(message->base.descriptor == &ping__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t ping__pack
                     (const Ping *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &ping__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t ping__pack_to_buffer
                     (const Ping *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &ping__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Ping *
       ping__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Ping *)
     protobuf_c_message_unpack (&ping__descriptor,
                                allocator, len, data);
}
void   ping__free_unpacked
                     (Ping *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &ping__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   success__init
                     (Success         *message)
{
  static Success init_value = SUCCESS__INIT;
  *message = init_value;
}
size_t success__get_packed_size
                     (const Success *message)
{
  assert(message->base.descriptor == &success__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t success__pack
                     (const Success *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &success__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t success__pack_to_buffer
                     (const Success *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &success__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Success *
       success__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Success *)
     protobuf_c_message_unpack (&success__descriptor,
                                allocator, len, data);
}
void   success__free_unpacked
                     (Success *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &success__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   failure__init
                     (Failure         *message)
{
  static Failure init_value = FAILURE__INIT;
  *message = init_value;
}
size_t failure__get_packed_size
                     (const Failure *message)
{
  assert(message->base.descriptor == &failure__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t failure__pack
                     (const Failure *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &failure__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t failure__pack_to_buffer
                     (const Failure *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &failure__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Failure *
       failure__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Failure *)
     protobuf_c_message_unpack (&failure__descriptor,
                                allocator, len, data);
}
void   failure__free_unpacked
                     (Failure *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &failure__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   button_request__init
                     (ButtonRequest         *message)
{
  static ButtonRequest init_value = BUTTON_REQUEST__INIT;
  *message = init_value;
}
size_t button_request__get_packed_size
                     (const ButtonRequest *message)
{
  assert(message->base.descriptor == &button_request__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t button_request__pack
                     (const ButtonRequest *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &button_request__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t button_request__pack_to_buffer
                     (const ButtonRequest *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &button_request__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
ButtonRequest *
       button_request__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (ButtonRequest *)
     protobuf_c_message_unpack (&button_request__descriptor,
                                allocator, len, data);
}
void   button_request__free_unpacked
                     (ButtonRequest *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &button_request__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   button_ack__init
                     (ButtonAck         *message)
{
  static ButtonAck init_value = BUTTON_ACK__INIT;
  *message = init_value;
}
size_t button_ack__get_packed_size
                     (const ButtonAck *message)
{
  assert(message->base.descriptor == &button_ack__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t button_ack__pack
                     (const ButtonAck *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &button_ack__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t button_ack__pack_to_buffer
                     (const ButtonAck *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &button_ack__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
ButtonAck *
       button_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (ButtonAck *)
     protobuf_c_message_unpack (&button_ack__descriptor,
                                allocator, len, data);
}
void   button_ack__free_unpacked
                     (ButtonAck *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &button_ack__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   pin_matrix_request__init
                     (PinMatrixRequest         *message)
{
  static PinMatrixRequest init_value = PIN_MATRIX_REQUEST__INIT;
  *message = init_value;
}
size_t pin_matrix_request__get_packed_size
                     (const PinMatrixRequest *message)
{
  assert(message->base.descriptor == &pin_matrix_request__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t pin_matrix_request__pack
                     (const PinMatrixRequest *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &pin_matrix_request__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t pin_matrix_request__pack_to_buffer
                     (const PinMatrixRequest *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &pin_matrix_request__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
PinMatrixRequest *
       pin_matrix_request__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (PinMatrixRequest *)
     protobuf_c_message_unpack (&pin_matrix_request__descriptor,
                                allocator, len, data);
}
void   pin_matrix_request__free_unpacked
                     (PinMatrixRequest *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &pin_matrix_request__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   pin_matrix_ack__init
                     (PinMatrixAck         *message)
{
  static PinMatrixAck init_value = PIN_MATRIX_ACK__INIT;
  *message = init_value;
}
size_t pin_matrix_ack__get_packed_size
                     (const PinMatrixAck *message)
{
  assert(message->base.descriptor == &pin_matrix_ack__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t pin_matrix_ack__pack
                     (const PinMatrixAck *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &pin_matrix_ack__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t pin_matrix_ack__pack_to_buffer
                     (const PinMatrixAck *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &pin_matrix_ack__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
PinMatrixAck *
       pin_matrix_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (PinMatrixAck *)
     protobuf_c_message_unpack (&pin_matrix_ack__descriptor,
                                allocator, len, data);
}
void   pin_matrix_ack__free_unpacked
                     (PinMatrixAck *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &pin_matrix_ack__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   cancel__init
                     (Cancel         *message)
{
  static Cancel init_value = CANCEL__INIT;
  *message = init_value;
}
size_t cancel__get_packed_size
                     (const Cancel *message)
{
  assert(message->base.descriptor == &cancel__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t cancel__pack
                     (const Cancel *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &cancel__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t cancel__pack_to_buffer
                     (const Cancel *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &cancel__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Cancel *
       cancel__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Cancel *)
     protobuf_c_message_unpack (&cancel__descriptor,
                                allocator, len, data);
}
void   cancel__free_unpacked
                     (Cancel *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &cancel__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   passphrase_request__init
                     (PassphraseRequest         *message)
{
  static PassphraseRequest init_value = PASSPHRASE_REQUEST__INIT;
  *message = init_value;
}
size_t passphrase_request__get_packed_size
                     (const PassphraseRequest *message)
{
  assert(message->base.descriptor == &passphrase_request__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t passphrase_request__pack
                     (const PassphraseRequest *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &passphrase_request__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t passphrase_request__pack_to_buffer
                     (const PassphraseRequest *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &passphrase_request__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
PassphraseRequest *
       passphrase_request__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (PassphraseRequest *)
     protobuf_c_message_unpack (&passphrase_request__descriptor,
                                allocator, len, data);
}
void   passphrase_request__free_unpacked
                     (PassphraseRequest *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &passphrase_request__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   passphrase_ack__init
                     (PassphraseAck         *message)
{
  static PassphraseAck init_value = PASSPHRASE_ACK__INIT;
  *message = init_value;
}
size_t passphrase_ack__get_packed_size
                     (const PassphraseAck *message)
{
  assert(message->base.descriptor == &passphrase_ack__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t passphrase_ack__pack
                     (const PassphraseAck *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &passphrase_ack__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t passphrase_ack__pack_to_buffer
                     (const PassphraseAck *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &passphrase_ack__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
PassphraseAck *
       passphrase_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (PassphraseAck *)
     protobuf_c_message_unpack (&passphrase_ack__descriptor,
                                allocator, len, data);
}
void   passphrase_ack__free_unpacked
                     (PassphraseAck *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &passphrase_ack__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   get_entropy__init
                     (GetEntropy         *message)
{
  static GetEntropy init_value = GET_ENTROPY__INIT;
  *message = init_value;
}
size_t get_entropy__get_packed_size
                     (const GetEntropy *message)
{
  assert(message->base.descriptor == &get_entropy__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t get_entropy__pack
                     (const GetEntropy *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &get_entropy__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t get_entropy__pack_to_buffer
                     (const GetEntropy *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &get_entropy__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GetEntropy *
       get_entropy__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GetEntropy *)
     protobuf_c_message_unpack (&get_entropy__descriptor,
                                allocator, len, data);
}
void   get_entropy__free_unpacked
                     (GetEntropy *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &get_entropy__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   entropy__init
                     (Entropy         *message)
{
  static Entropy init_value = ENTROPY__INIT;
  *message = init_value;
}
size_t entropy__get_packed_size
                     (const Entropy *message)
{
  assert(message->base.descriptor == &entropy__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t entropy__pack
                     (const Entropy *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &entropy__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t entropy__pack_to_buffer
                     (const Entropy *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &entropy__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Entropy *
       entropy__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Entropy *)
     protobuf_c_message_unpack (&entropy__descriptor,
                                allocator, len, data);
}
void   entropy__free_unpacked
                     (Entropy *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &entropy__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   get_public_key__init
                     (GetPublicKey         *message)
{
  static GetPublicKey init_value = GET_PUBLIC_KEY__INIT;
  *message = init_value;
}
size_t get_public_key__get_packed_size
                     (const GetPublicKey *message)
{
  assert(message->base.descriptor == &get_public_key__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t get_public_key__pack
                     (const GetPublicKey *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &get_public_key__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t get_public_key__pack_to_buffer
                     (const GetPublicKey *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &get_public_key__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GetPublicKey *
       get_public_key__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GetPublicKey *)
     protobuf_c_message_unpack (&get_public_key__descriptor,
                                allocator, len, data);
}
void   get_public_key__free_unpacked
                     (GetPublicKey *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &get_public_key__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   public_key__init
                     (PublicKey         *message)
{
  static PublicKey init_value = PUBLIC_KEY__INIT;
  *message = init_value;
}
size_t public_key__get_packed_size
                     (const PublicKey *message)
{
  assert(message->base.descriptor == &public_key__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t public_key__pack
                     (const PublicKey *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &public_key__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t public_key__pack_to_buffer
                     (const PublicKey *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &public_key__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
PublicKey *
       public_key__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (PublicKey *)
     protobuf_c_message_unpack (&public_key__descriptor,
                                allocator, len, data);
}
void   public_key__free_unpacked
                     (PublicKey *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &public_key__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   get_address__init
                     (GetAddress         *message)
{
  static GetAddress init_value = GET_ADDRESS__INIT;
  *message = init_value;
}
size_t get_address__get_packed_size
                     (const GetAddress *message)
{
  assert(message->base.descriptor == &get_address__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t get_address__pack
                     (const GetAddress *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &get_address__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t get_address__pack_to_buffer
                     (const GetAddress *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &get_address__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GetAddress *
       get_address__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GetAddress *)
     protobuf_c_message_unpack (&get_address__descriptor,
                                allocator, len, data);
}
void   get_address__free_unpacked
                     (GetAddress *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &get_address__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   ethereum_get_address__init
                     (EthereumGetAddress         *message)
{
  static EthereumGetAddress init_value = ETHEREUM_GET_ADDRESS__INIT;
  *message = init_value;
}
size_t ethereum_get_address__get_packed_size
                     (const EthereumGetAddress *message)
{
  assert(message->base.descriptor == &ethereum_get_address__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t ethereum_get_address__pack
                     (const EthereumGetAddress *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &ethereum_get_address__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t ethereum_get_address__pack_to_buffer
                     (const EthereumGetAddress *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &ethereum_get_address__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
EthereumGetAddress *
       ethereum_get_address__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (EthereumGetAddress *)
     protobuf_c_message_unpack (&ethereum_get_address__descriptor,
                                allocator, len, data);
}
void   ethereum_get_address__free_unpacked
                     (EthereumGetAddress *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &ethereum_get_address__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   address__init
                     (Address         *message)
{
  static Address init_value = ADDRESS__INIT;
  *message = init_value;
}
size_t address__get_packed_size
                     (const Address *message)
{
  assert(message->base.descriptor == &address__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t address__pack
                     (const Address *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &address__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t address__pack_to_buffer
                     (const Address *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &address__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Address *
       address__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Address *)
     protobuf_c_message_unpack (&address__descriptor,
                                allocator, len, data);
}
void   address__free_unpacked
                     (Address *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &address__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   ethereum_address__init
                     (EthereumAddress         *message)
{
  static EthereumAddress init_value = ETHEREUM_ADDRESS__INIT;
  *message = init_value;
}
size_t ethereum_address__get_packed_size
                     (const EthereumAddress *message)
{
  assert(message->base.descriptor == &ethereum_address__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t ethereum_address__pack
                     (const EthereumAddress *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &ethereum_address__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t ethereum_address__pack_to_buffer
                     (const EthereumAddress *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &ethereum_address__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
EthereumAddress *
       ethereum_address__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (EthereumAddress *)
     protobuf_c_message_unpack (&ethereum_address__descriptor,
                                allocator, len, data);
}
void   ethereum_address__free_unpacked
                     (EthereumAddress *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &ethereum_address__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   wipe_device__init
                     (WipeDevice         *message)
{
  static WipeDevice init_value = WIPE_DEVICE__INIT;
  *message = init_value;
}
size_t wipe_device__get_packed_size
                     (const WipeDevice *message)
{
  assert(message->base.descriptor == &wipe_device__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t wipe_device__pack
                     (const WipeDevice *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &wipe_device__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t wipe_device__pack_to_buffer
                     (const WipeDevice *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &wipe_device__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
WipeDevice *
       wipe_device__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (WipeDevice *)
     protobuf_c_message_unpack (&wipe_device__descriptor,
                                allocator, len, data);
}
void   wipe_device__free_unpacked
                     (WipeDevice *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &wipe_device__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   load_device__init
                     (LoadDevice         *message)
{
  static LoadDevice init_value = LOAD_DEVICE__INIT;
  *message = init_value;
}
size_t load_device__get_packed_size
                     (const LoadDevice *message)
{
  assert(message->base.descriptor == &load_device__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t load_device__pack
                     (const LoadDevice *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &load_device__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t load_device__pack_to_buffer
                     (const LoadDevice *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &load_device__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
LoadDevice *
       load_device__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (LoadDevice *)
     protobuf_c_message_unpack (&load_device__descriptor,
                                allocator, len, data);
}
void   load_device__free_unpacked
                     (LoadDevice *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &load_device__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   reset_device__init
                     (ResetDevice         *message)
{
  static ResetDevice init_value = RESET_DEVICE__INIT;
  *message = init_value;
}
size_t reset_device__get_packed_size
                     (const ResetDevice *message)
{
  assert(message->base.descriptor == &reset_device__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t reset_device__pack
                     (const ResetDevice *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &reset_device__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t reset_device__pack_to_buffer
                     (const ResetDevice *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &reset_device__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
ResetDevice *
       reset_device__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (ResetDevice *)
     protobuf_c_message_unpack (&reset_device__descriptor,
                                allocator, len, data);
}
void   reset_device__free_unpacked
                     (ResetDevice *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &reset_device__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   entropy_request__init
                     (EntropyRequest         *message)
{
  static EntropyRequest init_value = ENTROPY_REQUEST__INIT;
  *message = init_value;
}
size_t entropy_request__get_packed_size
                     (const EntropyRequest *message)
{
  assert(message->base.descriptor == &entropy_request__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t entropy_request__pack
                     (const EntropyRequest *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &entropy_request__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t entropy_request__pack_to_buffer
                     (const EntropyRequest *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &entropy_request__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
EntropyRequest *
       entropy_request__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (EntropyRequest *)
     protobuf_c_message_unpack (&entropy_request__descriptor,
                                allocator, len, data);
}
void   entropy_request__free_unpacked
                     (EntropyRequest *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &entropy_request__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   entropy_ack__init
                     (EntropyAck         *message)
{
  static EntropyAck init_value = ENTROPY_ACK__INIT;
  *message = init_value;
}
size_t entropy_ack__get_packed_size
                     (const EntropyAck *message)
{
  assert(message->base.descriptor == &entropy_ack__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t entropy_ack__pack
                     (const EntropyAck *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &entropy_ack__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t entropy_ack__pack_to_buffer
                     (const EntropyAck *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &entropy_ack__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
EntropyAck *
       entropy_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (EntropyAck *)
     protobuf_c_message_unpack (&entropy_ack__descriptor,
                                allocator, len, data);
}
void   entropy_ack__free_unpacked
                     (EntropyAck *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &entropy_ack__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   recovery_device__init
                     (RecoveryDevice         *message)
{
  static RecoveryDevice init_value = RECOVERY_DEVICE__INIT;
  *message = init_value;
}
size_t recovery_device__get_packed_size
                     (const RecoveryDevice *message)
{
  assert(message->base.descriptor == &recovery_device__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t recovery_device__pack
                     (const RecoveryDevice *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &recovery_device__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t recovery_device__pack_to_buffer
                     (const RecoveryDevice *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &recovery_device__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
RecoveryDevice *
       recovery_device__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (RecoveryDevice *)
     protobuf_c_message_unpack (&recovery_device__descriptor,
                                allocator, len, data);
}
void   recovery_device__free_unpacked
                     (RecoveryDevice *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &recovery_device__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   word_request__init
                     (WordRequest         *message)
{
  static WordRequest init_value = WORD_REQUEST__INIT;
  *message = init_value;
}
size_t word_request__get_packed_size
                     (const WordRequest *message)
{
  assert(message->base.descriptor == &word_request__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t word_request__pack
                     (const WordRequest *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &word_request__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t word_request__pack_to_buffer
                     (const WordRequest *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &word_request__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
WordRequest *
       word_request__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (WordRequest *)
     protobuf_c_message_unpack (&word_request__descriptor,
                                allocator, len, data);
}
void   word_request__free_unpacked
                     (WordRequest *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &word_request__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   word_ack__init
                     (WordAck         *message)
{
  static WordAck init_value = WORD_ACK__INIT;
  *message = init_value;
}
size_t word_ack__get_packed_size
                     (const WordAck *message)
{
  assert(message->base.descriptor == &word_ack__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t word_ack__pack
                     (const WordAck *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &word_ack__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t word_ack__pack_to_buffer
                     (const WordAck *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &word_ack__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
WordAck *
       word_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (WordAck *)
     protobuf_c_message_unpack (&word_ack__descriptor,
                                allocator, len, data);
}
void   word_ack__free_unpacked
                     (WordAck *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &word_ack__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   sign_message__init
                     (SignMessage         *message)
{
  static SignMessage init_value = SIGN_MESSAGE__INIT;
  *message = init_value;
}
size_t sign_message__get_packed_size
                     (const SignMessage *message)
{
  assert(message->base.descriptor == &sign_message__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t sign_message__pack
                     (const SignMessage *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &sign_message__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t sign_message__pack_to_buffer
                     (const SignMessage *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &sign_message__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
SignMessage *
       sign_message__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (SignMessage *)
     protobuf_c_message_unpack (&sign_message__descriptor,
                                allocator, len, data);
}
void   sign_message__free_unpacked
                     (SignMessage *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &sign_message__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   verify_message__init
                     (VerifyMessage         *message)
{
  static VerifyMessage init_value = VERIFY_MESSAGE__INIT;
  *message = init_value;
}
size_t verify_message__get_packed_size
                     (const VerifyMessage *message)
{
  assert(message->base.descriptor == &verify_message__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t verify_message__pack
                     (const VerifyMessage *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &verify_message__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t verify_message__pack_to_buffer
                     (const VerifyMessage *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &verify_message__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
VerifyMessage *
       verify_message__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (VerifyMessage *)
     protobuf_c_message_unpack (&verify_message__descriptor,
                                allocator, len, data);
}
void   verify_message__free_unpacked
                     (VerifyMessage *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &verify_message__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   message_signature__init
                     (MessageSignature         *message)
{
  static MessageSignature init_value = MESSAGE_SIGNATURE__INIT;
  *message = init_value;
}
size_t message_signature__get_packed_size
                     (const MessageSignature *message)
{
  assert(message->base.descriptor == &message_signature__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t message_signature__pack
                     (const MessageSignature *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &message_signature__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t message_signature__pack_to_buffer
                     (const MessageSignature *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &message_signature__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
MessageSignature *
       message_signature__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (MessageSignature *)
     protobuf_c_message_unpack (&message_signature__descriptor,
                                allocator, len, data);
}
void   message_signature__free_unpacked
                     (MessageSignature *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &message_signature__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   encrypt_message__init
                     (EncryptMessage         *message)
{
  static EncryptMessage init_value = ENCRYPT_MESSAGE__INIT;
  *message = init_value;
}
size_t encrypt_message__get_packed_size
                     (const EncryptMessage *message)
{
  assert(message->base.descriptor == &encrypt_message__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t encrypt_message__pack
                     (const EncryptMessage *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &encrypt_message__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t encrypt_message__pack_to_buffer
                     (const EncryptMessage *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &encrypt_message__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
EncryptMessage *
       encrypt_message__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (EncryptMessage *)
     protobuf_c_message_unpack (&encrypt_message__descriptor,
                                allocator, len, data);
}
void   encrypt_message__free_unpacked
                     (EncryptMessage *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &encrypt_message__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   encrypted_message__init
                     (EncryptedMessage         *message)
{
  static EncryptedMessage init_value = ENCRYPTED_MESSAGE__INIT;
  *message = init_value;
}
size_t encrypted_message__get_packed_size
                     (const EncryptedMessage *message)
{
  assert(message->base.descriptor == &encrypted_message__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t encrypted_message__pack
                     (const EncryptedMessage *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &encrypted_message__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t encrypted_message__pack_to_buffer
                     (const EncryptedMessage *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &encrypted_message__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
EncryptedMessage *
       encrypted_message__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (EncryptedMessage *)
     protobuf_c_message_unpack (&encrypted_message__descriptor,
                                allocator, len, data);
}
void   encrypted_message__free_unpacked
                     (EncryptedMessage *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &encrypted_message__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   decrypt_message__init
                     (DecryptMessage         *message)
{
  static DecryptMessage init_value = DECRYPT_MESSAGE__INIT;
  *message = init_value;
}
size_t decrypt_message__get_packed_size
                     (const DecryptMessage *message)
{
  assert(message->base.descriptor == &decrypt_message__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t decrypt_message__pack
                     (const DecryptMessage *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &decrypt_message__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t decrypt_message__pack_to_buffer
                     (const DecryptMessage *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &decrypt_message__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
DecryptMessage *
       decrypt_message__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (DecryptMessage *)
     protobuf_c_message_unpack (&decrypt_message__descriptor,
                                allocator, len, data);
}
void   decrypt_message__free_unpacked
                     (DecryptMessage *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &decrypt_message__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   decrypted_message__init
                     (DecryptedMessage         *message)
{
  static DecryptedMessage init_value = DECRYPTED_MESSAGE__INIT;
  *message = init_value;
}
size_t decrypted_message__get_packed_size
                     (const DecryptedMessage *message)
{
  assert(message->base.descriptor == &decrypted_message__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t decrypted_message__pack
                     (const DecryptedMessage *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &decrypted_message__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t decrypted_message__pack_to_buffer
                     (const DecryptedMessage *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &decrypted_message__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
DecryptedMessage *
       decrypted_message__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (DecryptedMessage *)
     protobuf_c_message_unpack (&decrypted_message__descriptor,
                                allocator, len, data);
}
void   decrypted_message__free_unpacked
                     (DecryptedMessage *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &decrypted_message__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   cipher_key_value__init
                     (CipherKeyValue         *message)
{
  static CipherKeyValue init_value = CIPHER_KEY_VALUE__INIT;
  *message = init_value;
}
size_t cipher_key_value__get_packed_size
                     (const CipherKeyValue *message)
{
  assert(message->base.descriptor == &cipher_key_value__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t cipher_key_value__pack
                     (const CipherKeyValue *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &cipher_key_value__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t cipher_key_value__pack_to_buffer
                     (const CipherKeyValue *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &cipher_key_value__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
CipherKeyValue *
       cipher_key_value__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (CipherKeyValue *)
     protobuf_c_message_unpack (&cipher_key_value__descriptor,
                                allocator, len, data);
}
void   cipher_key_value__free_unpacked
                     (CipherKeyValue *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &cipher_key_value__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   ciphered_key_value__init
                     (CipheredKeyValue         *message)
{
  static CipheredKeyValue init_value = CIPHERED_KEY_VALUE__INIT;
  *message = init_value;
}
size_t ciphered_key_value__get_packed_size
                     (const CipheredKeyValue *message)
{
  assert(message->base.descriptor == &ciphered_key_value__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t ciphered_key_value__pack
                     (const CipheredKeyValue *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &ciphered_key_value__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t ciphered_key_value__pack_to_buffer
                     (const CipheredKeyValue *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &ciphered_key_value__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
CipheredKeyValue *
       ciphered_key_value__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (CipheredKeyValue *)
     protobuf_c_message_unpack (&ciphered_key_value__descriptor,
                                allocator, len, data);
}
void   ciphered_key_value__free_unpacked
                     (CipheredKeyValue *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &ciphered_key_value__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   estimate_tx_size__init
                     (EstimateTxSize         *message)
{
  static EstimateTxSize init_value = ESTIMATE_TX_SIZE__INIT;
  *message = init_value;
}
size_t estimate_tx_size__get_packed_size
                     (const EstimateTxSize *message)
{
  assert(message->base.descriptor == &estimate_tx_size__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t estimate_tx_size__pack
                     (const EstimateTxSize *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &estimate_tx_size__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t estimate_tx_size__pack_to_buffer
                     (const EstimateTxSize *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &estimate_tx_size__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
EstimateTxSize *
       estimate_tx_size__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (EstimateTxSize *)
     protobuf_c_message_unpack (&estimate_tx_size__descriptor,
                                allocator, len, data);
}
void   estimate_tx_size__free_unpacked
                     (EstimateTxSize *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &estimate_tx_size__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   tx_size__init
                     (TxSize         *message)
{
  static TxSize init_value = TX_SIZE__INIT;
  *message = init_value;
}
size_t tx_size__get_packed_size
                     (const TxSize *message)
{
  assert(message->base.descriptor == &tx_size__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t tx_size__pack
                     (const TxSize *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &tx_size__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t tx_size__pack_to_buffer
                     (const TxSize *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &tx_size__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
TxSize *
       tx_size__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (TxSize *)
     protobuf_c_message_unpack (&tx_size__descriptor,
                                allocator, len, data);
}
void   tx_size__free_unpacked
                     (TxSize *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &tx_size__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   sign_tx__init
                     (SignTx         *message)
{
  static SignTx init_value = SIGN_TX__INIT;
  *message = init_value;
}
size_t sign_tx__get_packed_size
                     (const SignTx *message)
{
  assert(message->base.descriptor == &sign_tx__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t sign_tx__pack
                     (const SignTx *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &sign_tx__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t sign_tx__pack_to_buffer
                     (const SignTx *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &sign_tx__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
SignTx *
       sign_tx__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (SignTx *)
     protobuf_c_message_unpack (&sign_tx__descriptor,
                                allocator, len, data);
}
void   sign_tx__free_unpacked
                     (SignTx *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &sign_tx__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   simple_sign_tx__init
                     (SimpleSignTx         *message)
{
  static SimpleSignTx init_value = SIMPLE_SIGN_TX__INIT;
  *message = init_value;
}
size_t simple_sign_tx__get_packed_size
                     (const SimpleSignTx *message)
{
  assert(message->base.descriptor == &simple_sign_tx__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t simple_sign_tx__pack
                     (const SimpleSignTx *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &simple_sign_tx__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t simple_sign_tx__pack_to_buffer
                     (const SimpleSignTx *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &simple_sign_tx__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
SimpleSignTx *
       simple_sign_tx__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (SimpleSignTx *)
     protobuf_c_message_unpack (&simple_sign_tx__descriptor,
                                allocator, len, data);
}
void   simple_sign_tx__free_unpacked
                     (SimpleSignTx *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &simple_sign_tx__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   tx_request__init
                     (TxRequest         *message)
{
  static TxRequest init_value = TX_REQUEST__INIT;
  *message = init_value;
}
size_t tx_request__get_packed_size
                     (const TxRequest *message)
{
  assert(message->base.descriptor == &tx_request__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t tx_request__pack
                     (const TxRequest *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &tx_request__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t tx_request__pack_to_buffer
                     (const TxRequest *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &tx_request__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
TxRequest *
       tx_request__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (TxRequest *)
     protobuf_c_message_unpack (&tx_request__descriptor,
                                allocator, len, data);
}
void   tx_request__free_unpacked
                     (TxRequest *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &tx_request__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   tx_ack__init
                     (TxAck         *message)
{
  static TxAck init_value = TX_ACK__INIT;
  *message = init_value;
}
size_t tx_ack__get_packed_size
                     (const TxAck *message)
{
  assert(message->base.descriptor == &tx_ack__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t tx_ack__pack
                     (const TxAck *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &tx_ack__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t tx_ack__pack_to_buffer
                     (const TxAck *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &tx_ack__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
TxAck *
       tx_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (TxAck *)
     protobuf_c_message_unpack (&tx_ack__descriptor,
                                allocator, len, data);
}
void   tx_ack__free_unpacked
                     (TxAck *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &tx_ack__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   ethereum_sign_tx__init
                     (EthereumSignTx         *message)
{
  static EthereumSignTx init_value = ETHEREUM_SIGN_TX__INIT;
  *message = init_value;
}
size_t ethereum_sign_tx__get_packed_size
                     (const EthereumSignTx *message)
{
  assert(message->base.descriptor == &ethereum_sign_tx__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t ethereum_sign_tx__pack
                     (const EthereumSignTx *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &ethereum_sign_tx__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t ethereum_sign_tx__pack_to_buffer
                     (const EthereumSignTx *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &ethereum_sign_tx__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
EthereumSignTx *
       ethereum_sign_tx__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (EthereumSignTx *)
     protobuf_c_message_unpack (&ethereum_sign_tx__descriptor,
                                allocator, len, data);
}
void   ethereum_sign_tx__free_unpacked
                     (EthereumSignTx *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &ethereum_sign_tx__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   ethereum_tx_request__init
                     (EthereumTxRequest         *message)
{
  static EthereumTxRequest init_value = ETHEREUM_TX_REQUEST__INIT;
  *message = init_value;
}
size_t ethereum_tx_request__get_packed_size
                     (const EthereumTxRequest *message)
{
  assert(message->base.descriptor == &ethereum_tx_request__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t ethereum_tx_request__pack
                     (const EthereumTxRequest *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &ethereum_tx_request__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t ethereum_tx_request__pack_to_buffer
                     (const EthereumTxRequest *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &ethereum_tx_request__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
EthereumTxRequest *
       ethereum_tx_request__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (EthereumTxRequest *)
     protobuf_c_message_unpack (&ethereum_tx_request__descriptor,
                                allocator, len, data);
}
void   ethereum_tx_request__free_unpacked
                     (EthereumTxRequest *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &ethereum_tx_request__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   ethereum_tx_ack__init
                     (EthereumTxAck         *message)
{
  static EthereumTxAck init_value = ETHEREUM_TX_ACK__INIT;
  *message = init_value;
}
size_t ethereum_tx_ack__get_packed_size
                     (const EthereumTxAck *message)
{
  assert(message->base.descriptor == &ethereum_tx_ack__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t ethereum_tx_ack__pack
                     (const EthereumTxAck *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &ethereum_tx_ack__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t ethereum_tx_ack__pack_to_buffer
                     (const EthereumTxAck *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &ethereum_tx_ack__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
EthereumTxAck *
       ethereum_tx_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (EthereumTxAck *)
     protobuf_c_message_unpack (&ethereum_tx_ack__descriptor,
                                allocator, len, data);
}
void   ethereum_tx_ack__free_unpacked
                     (EthereumTxAck *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &ethereum_tx_ack__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   sign_identity__init
                     (SignIdentity         *message)
{
  static SignIdentity init_value = SIGN_IDENTITY__INIT;
  *message = init_value;
}
size_t sign_identity__get_packed_size
                     (const SignIdentity *message)
{
  assert(message->base.descriptor == &sign_identity__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t sign_identity__pack
                     (const SignIdentity *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &sign_identity__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t sign_identity__pack_to_buffer
                     (const SignIdentity *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &sign_identity__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
SignIdentity *
       sign_identity__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (SignIdentity *)
     protobuf_c_message_unpack (&sign_identity__descriptor,
                                allocator, len, data);
}
void   sign_identity__free_unpacked
                     (SignIdentity *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &sign_identity__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   signed_identity__init
                     (SignedIdentity         *message)
{
  static SignedIdentity init_value = SIGNED_IDENTITY__INIT;
  *message = init_value;
}
size_t signed_identity__get_packed_size
                     (const SignedIdentity *message)
{
  assert(message->base.descriptor == &signed_identity__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t signed_identity__pack
                     (const SignedIdentity *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &signed_identity__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t signed_identity__pack_to_buffer
                     (const SignedIdentity *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &signed_identity__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
SignedIdentity *
       signed_identity__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (SignedIdentity *)
     protobuf_c_message_unpack (&signed_identity__descriptor,
                                allocator, len, data);
}
void   signed_identity__free_unpacked
                     (SignedIdentity *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &signed_identity__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   get_ecdhsession_key__init
                     (GetECDHSessionKey         *message)
{
  static GetECDHSessionKey init_value = GET_ECDHSESSION_KEY__INIT;
  *message = init_value;
}
size_t get_ecdhsession_key__get_packed_size
                     (const GetECDHSessionKey *message)
{
  assert(message->base.descriptor == &get_ecdhsession_key__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t get_ecdhsession_key__pack
                     (const GetECDHSessionKey *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &get_ecdhsession_key__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t get_ecdhsession_key__pack_to_buffer
                     (const GetECDHSessionKey *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &get_ecdhsession_key__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GetECDHSessionKey *
       get_ecdhsession_key__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GetECDHSessionKey *)
     protobuf_c_message_unpack (&get_ecdhsession_key__descriptor,
                                allocator, len, data);
}
void   get_ecdhsession_key__free_unpacked
                     (GetECDHSessionKey *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &get_ecdhsession_key__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   ecdhsession_key__init
                     (ECDHSessionKey         *message)
{
  static ECDHSessionKey init_value = ECDHSESSION_KEY__INIT;
  *message = init_value;
}
size_t ecdhsession_key__get_packed_size
                     (const ECDHSessionKey *message)
{
  assert(message->base.descriptor == &ecdhsession_key__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t ecdhsession_key__pack
                     (const ECDHSessionKey *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &ecdhsession_key__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t ecdhsession_key__pack_to_buffer
                     (const ECDHSessionKey *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &ecdhsession_key__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
ECDHSessionKey *
       ecdhsession_key__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (ECDHSessionKey *)
     protobuf_c_message_unpack (&ecdhsession_key__descriptor,
                                allocator, len, data);
}
void   ecdhsession_key__free_unpacked
                     (ECDHSessionKey *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &ecdhsession_key__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   set_u2_fcounter__init
                     (SetU2FCounter         *message)
{
  static SetU2FCounter init_value = SET_U2_FCOUNTER__INIT;
  *message = init_value;
}
size_t set_u2_fcounter__get_packed_size
                     (const SetU2FCounter *message)
{
  assert(message->base.descriptor == &set_u2_fcounter__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t set_u2_fcounter__pack
                     (const SetU2FCounter *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &set_u2_fcounter__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t set_u2_fcounter__pack_to_buffer
                     (const SetU2FCounter *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &set_u2_fcounter__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
SetU2FCounter *
       set_u2_fcounter__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (SetU2FCounter *)
     protobuf_c_message_unpack (&set_u2_fcounter__descriptor,
                                allocator, len, data);
}
void   set_u2_fcounter__free_unpacked
                     (SetU2FCounter *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &set_u2_fcounter__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   firmware_erase__init
                     (FirmwareErase         *message)
{
  static FirmwareErase init_value = FIRMWARE_ERASE__INIT;
  *message = init_value;
}
size_t firmware_erase__get_packed_size
                     (const FirmwareErase *message)
{
  assert(message->base.descriptor == &firmware_erase__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t firmware_erase__pack
                     (const FirmwareErase *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &firmware_erase__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t firmware_erase__pack_to_buffer
                     (const FirmwareErase *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &firmware_erase__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
FirmwareErase *
       firmware_erase__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (FirmwareErase *)
     protobuf_c_message_unpack (&firmware_erase__descriptor,
                                allocator, len, data);
}
void   firmware_erase__free_unpacked
                     (FirmwareErase *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &firmware_erase__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   firmware_upload__init
                     (FirmwareUpload         *message)
{
  static FirmwareUpload init_value = FIRMWARE_UPLOAD__INIT;
  *message = init_value;
}
size_t firmware_upload__get_packed_size
                     (const FirmwareUpload *message)
{
  assert(message->base.descriptor == &firmware_upload__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t firmware_upload__pack
                     (const FirmwareUpload *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &firmware_upload__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t firmware_upload__pack_to_buffer
                     (const FirmwareUpload *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &firmware_upload__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
FirmwareUpload *
       firmware_upload__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (FirmwareUpload *)
     protobuf_c_message_unpack (&firmware_upload__descriptor,
                                allocator, len, data);
}
void   firmware_upload__free_unpacked
                     (FirmwareUpload *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &firmware_upload__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   debug_link_decision__init
                     (DebugLinkDecision         *message)
{
  static DebugLinkDecision init_value = DEBUG_LINK_DECISION__INIT;
  *message = init_value;
}
size_t debug_link_decision__get_packed_size
                     (const DebugLinkDecision *message)
{
  assert(message->base.descriptor == &debug_link_decision__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t debug_link_decision__pack
                     (const DebugLinkDecision *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &debug_link_decision__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t debug_link_decision__pack_to_buffer
                     (const DebugLinkDecision *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &debug_link_decision__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
DebugLinkDecision *
       debug_link_decision__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (DebugLinkDecision *)
     protobuf_c_message_unpack (&debug_link_decision__descriptor,
                                allocator, len, data);
}
void   debug_link_decision__free_unpacked
                     (DebugLinkDecision *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &debug_link_decision__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   debug_link_get_state__init
                     (DebugLinkGetState         *message)
{
  static DebugLinkGetState init_value = DEBUG_LINK_GET_STATE__INIT;
  *message = init_value;
}
size_t debug_link_get_state__get_packed_size
                     (const DebugLinkGetState *message)
{
  assert(message->base.descriptor == &debug_link_get_state__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t debug_link_get_state__pack
                     (const DebugLinkGetState *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &debug_link_get_state__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t debug_link_get_state__pack_to_buffer
                     (const DebugLinkGetState *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &debug_link_get_state__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
DebugLinkGetState *
       debug_link_get_state__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (DebugLinkGetState *)
     protobuf_c_message_unpack (&debug_link_get_state__descriptor,
                                allocator, len, data);
}
void   debug_link_get_state__free_unpacked
                     (DebugLinkGetState *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &debug_link_get_state__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   debug_link_state__init
                     (DebugLinkState         *message)
{
  static DebugLinkState init_value = DEBUG_LINK_STATE__INIT;
  *message = init_value;
}
size_t debug_link_state__get_packed_size
                     (const DebugLinkState *message)
{
  assert(message->base.descriptor == &debug_link_state__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t debug_link_state__pack
                     (const DebugLinkState *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &debug_link_state__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t debug_link_state__pack_to_buffer
                     (const DebugLinkState *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &debug_link_state__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
DebugLinkState *
       debug_link_state__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (DebugLinkState *)
     protobuf_c_message_unpack (&debug_link_state__descriptor,
                                allocator, len, data);
}
void   debug_link_state__free_unpacked
                     (DebugLinkState *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &debug_link_state__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   debug_link_stop__init
                     (DebugLinkStop         *message)
{
  static DebugLinkStop init_value = DEBUG_LINK_STOP__INIT;
  *message = init_value;
}
size_t debug_link_stop__get_packed_size
                     (const DebugLinkStop *message)
{
  assert(message->base.descriptor == &debug_link_stop__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t debug_link_stop__pack
                     (const DebugLinkStop *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &debug_link_stop__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t debug_link_stop__pack_to_buffer
                     (const DebugLinkStop *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &debug_link_stop__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
DebugLinkStop *
       debug_link_stop__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (DebugLinkStop *)
     protobuf_c_message_unpack (&debug_link_stop__descriptor,
                                allocator, len, data);
}
void   debug_link_stop__free_unpacked
                     (DebugLinkStop *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &debug_link_stop__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   debug_link_log__init
                     (DebugLinkLog         *message)
{
  static DebugLinkLog init_value = DEBUG_LINK_LOG__INIT;
  *message = init_value;
}
size_t debug_link_log__get_packed_size
                     (const DebugLinkLog *message)
{
  assert(message->base.descriptor == &debug_link_log__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t debug_link_log__pack
                     (const DebugLinkLog *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &debug_link_log__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t debug_link_log__pack_to_buffer
                     (const DebugLinkLog *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &debug_link_log__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
DebugLinkLog *
       debug_link_log__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (DebugLinkLog *)
     protobuf_c_message_unpack (&debug_link_log__descriptor,
                                allocator, len, data);
}
void   debug_link_log__free_unpacked
                     (DebugLinkLog *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &debug_link_log__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   debug_link_memory_read__init
                     (DebugLinkMemoryRead         *message)
{
  static DebugLinkMemoryRead init_value = DEBUG_LINK_MEMORY_READ__INIT;
  *message = init_value;
}
size_t debug_link_memory_read__get_packed_size
                     (const DebugLinkMemoryRead *message)
{
  assert(message->base.descriptor == &debug_link_memory_read__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t debug_link_memory_read__pack
                     (const DebugLinkMemoryRead *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &debug_link_memory_read__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t debug_link_memory_read__pack_to_buffer
                     (const DebugLinkMemoryRead *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &debug_link_memory_read__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
DebugLinkMemoryRead *
       debug_link_memory_read__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (DebugLinkMemoryRead *)
     protobuf_c_message_unpack (&debug_link_memory_read__descriptor,
                                allocator, len, data);
}
void   debug_link_memory_read__free_unpacked
                     (DebugLinkMemoryRead *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &debug_link_memory_read__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   debug_link_memory__init
                     (DebugLinkMemory         *message)
{
  static DebugLinkMemory init_value = DEBUG_LINK_MEMORY__INIT;
  *message = init_value;
}
size_t debug_link_memory__get_packed_size
                     (const DebugLinkMemory *message)
{
  assert(message->base.descriptor == &debug_link_memory__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t debug_link_memory__pack
                     (const DebugLinkMemory *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &debug_link_memory__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t debug_link_memory__pack_to_buffer
                     (const DebugLinkMemory *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &debug_link_memory__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
DebugLinkMemory *
       debug_link_memory__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (DebugLinkMemory *)
     protobuf_c_message_unpack (&debug_link_memory__descriptor,
                                allocator, len, data);
}
void   debug_link_memory__free_unpacked
                     (DebugLinkMemory *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &debug_link_memory__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   debug_link_memory_write__init
                     (DebugLinkMemoryWrite         *message)
{
  static DebugLinkMemoryWrite init_value = DEBUG_LINK_MEMORY_WRITE__INIT;
  *message = init_value;
}
size_t debug_link_memory_write__get_packed_size
                     (const DebugLinkMemoryWrite *message)
{
  assert(message->base.descriptor == &debug_link_memory_write__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t debug_link_memory_write__pack
                     (const DebugLinkMemoryWrite *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &debug_link_memory_write__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t debug_link_memory_write__pack_to_buffer
                     (const DebugLinkMemoryWrite *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &debug_link_memory_write__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
DebugLinkMemoryWrite *
       debug_link_memory_write__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (DebugLinkMemoryWrite *)
     protobuf_c_message_unpack (&debug_link_memory_write__descriptor,
                                allocator, len, data);
}
void   debug_link_memory_write__free_unpacked
                     (DebugLinkMemoryWrite *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &debug_link_memory_write__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   debug_link_flash_erase__init
                     (DebugLinkFlashErase         *message)
{
  static DebugLinkFlashErase init_value = DEBUG_LINK_FLASH_ERASE__INIT;
  *message = init_value;
}
size_t debug_link_flash_erase__get_packed_size
                     (const DebugLinkFlashErase *message)
{
  assert(message->base.descriptor == &debug_link_flash_erase__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t debug_link_flash_erase__pack
                     (const DebugLinkFlashErase *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &debug_link_flash_erase__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t debug_link_flash_erase__pack_to_buffer
                     (const DebugLinkFlashErase *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &debug_link_flash_erase__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
DebugLinkFlashErase *
       debug_link_flash_erase__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (DebugLinkFlashErase *)
     protobuf_c_message_unpack (&debug_link_flash_erase__descriptor,
                                allocator, len, data);
}
void   debug_link_flash_erase__free_unpacked
                     (DebugLinkFlashErase *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &debug_link_flash_erase__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   xmr_request_session_key__init
                     (XmrRequestSessionKey         *message)
{
  static XmrRequestSessionKey init_value = XMR_REQUEST_SESSION_KEY__INIT;
  *message = init_value;
}
size_t xmr_request_session_key__get_packed_size
                     (const XmrRequestSessionKey *message)
{
  assert(message->base.descriptor == &xmr_request_session_key__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t xmr_request_session_key__pack
                     (const XmrRequestSessionKey *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &xmr_request_session_key__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t xmr_request_session_key__pack_to_buffer
                     (const XmrRequestSessionKey *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &xmr_request_session_key__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
XmrRequestSessionKey *
       xmr_request_session_key__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (XmrRequestSessionKey *)
     protobuf_c_message_unpack (&xmr_request_session_key__descriptor,
                                allocator, len, data);
}
void   xmr_request_session_key__free_unpacked
                     (XmrRequestSessionKey *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &xmr_request_session_key__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   xmr_request_session_key_ack__init
                     (XmrRequestSessionKeyAck         *message)
{
  static XmrRequestSessionKeyAck init_value = XMR_REQUEST_SESSION_KEY_ACK__INIT;
  *message = init_value;
}
size_t xmr_request_session_key_ack__get_packed_size
                     (const XmrRequestSessionKeyAck *message)
{
  assert(message->base.descriptor == &xmr_request_session_key_ack__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t xmr_request_session_key_ack__pack
                     (const XmrRequestSessionKeyAck *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &xmr_request_session_key_ack__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t xmr_request_session_key_ack__pack_to_buffer
                     (const XmrRequestSessionKeyAck *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &xmr_request_session_key_ack__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
XmrRequestSessionKeyAck *
       xmr_request_session_key_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (XmrRequestSessionKeyAck *)
     protobuf_c_message_unpack (&xmr_request_session_key_ack__descriptor,
                                allocator, len, data);
}
void   xmr_request_session_key_ack__free_unpacked
                     (XmrRequestSessionKeyAck *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &xmr_request_session_key_ack__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   xmr_request_view_key__init
                     (XmrRequestViewKey         *message)
{
  static XmrRequestViewKey init_value = XMR_REQUEST_VIEW_KEY__INIT;
  *message = init_value;
}
size_t xmr_request_view_key__get_packed_size
                     (const XmrRequestViewKey *message)
{
  assert(message->base.descriptor == &xmr_request_view_key__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t xmr_request_view_key__pack
                     (const XmrRequestViewKey *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &xmr_request_view_key__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t xmr_request_view_key__pack_to_buffer
                     (const XmrRequestViewKey *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &xmr_request_view_key__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
XmrRequestViewKey *
       xmr_request_view_key__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (XmrRequestViewKey *)
     protobuf_c_message_unpack (&xmr_request_view_key__descriptor,
                                allocator, len, data);
}
void   xmr_request_view_key__free_unpacked
                     (XmrRequestViewKey *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &xmr_request_view_key__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   xmr_request_view_key_ack__init
                     (XmrRequestViewKeyAck         *message)
{
  static XmrRequestViewKeyAck init_value = XMR_REQUEST_VIEW_KEY_ACK__INIT;
  *message = init_value;
}
size_t xmr_request_view_key_ack__get_packed_size
                     (const XmrRequestViewKeyAck *message)
{
  assert(message->base.descriptor == &xmr_request_view_key_ack__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t xmr_request_view_key_ack__pack
                     (const XmrRequestViewKeyAck *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &xmr_request_view_key_ack__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t xmr_request_view_key_ack__pack_to_buffer
                     (const XmrRequestViewKeyAck *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &xmr_request_view_key_ack__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
XmrRequestViewKeyAck *
       xmr_request_view_key_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (XmrRequestViewKeyAck *)
     protobuf_c_message_unpack (&xmr_request_view_key_ack__descriptor,
                                allocator, len, data);
}
void   xmr_request_view_key_ack__free_unpacked
                     (XmrRequestViewKeyAck *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &xmr_request_view_key_ack__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   xmr_generate_key_image__init
                     (XmrGenerateKeyImage         *message)
{
  static XmrGenerateKeyImage init_value = XMR_GENERATE_KEY_IMAGE__INIT;
  *message = init_value;
}
size_t xmr_generate_key_image__get_packed_size
                     (const XmrGenerateKeyImage *message)
{
  assert(message->base.descriptor == &xmr_generate_key_image__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t xmr_generate_key_image__pack
                     (const XmrGenerateKeyImage *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &xmr_generate_key_image__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t xmr_generate_key_image__pack_to_buffer
                     (const XmrGenerateKeyImage *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &xmr_generate_key_image__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
XmrGenerateKeyImage *
       xmr_generate_key_image__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (XmrGenerateKeyImage *)
     protobuf_c_message_unpack (&xmr_generate_key_image__descriptor,
                                allocator, len, data);
}
void   xmr_generate_key_image__free_unpacked
                     (XmrGenerateKeyImage *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &xmr_generate_key_image__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   xmr_generate_key_image_ack__init
                     (XmrGenerateKeyImageAck         *message)
{
  static XmrGenerateKeyImageAck init_value = XMR_GENERATE_KEY_IMAGE_ACK__INIT;
  *message = init_value;
}
size_t xmr_generate_key_image_ack__get_packed_size
                     (const XmrGenerateKeyImageAck *message)
{
  assert(message->base.descriptor == &xmr_generate_key_image_ack__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t xmr_generate_key_image_ack__pack
                     (const XmrGenerateKeyImageAck *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &xmr_generate_key_image_ack__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t xmr_generate_key_image_ack__pack_to_buffer
                     (const XmrGenerateKeyImageAck *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &xmr_generate_key_image_ack__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
XmrGenerateKeyImageAck *
       xmr_generate_key_image_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (XmrGenerateKeyImageAck *)
     protobuf_c_message_unpack (&xmr_generate_key_image_ack__descriptor,
                                allocator, len, data);
}
void   xmr_generate_key_image_ack__free_unpacked
                     (XmrGenerateKeyImageAck *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &xmr_generate_key_image_ack__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   xmr_generate_signature__init
                     (XmrGenerateSignature         *message)
{
  static XmrGenerateSignature init_value = XMR_GENERATE_SIGNATURE__INIT;
  *message = init_value;
}
size_t xmr_generate_signature__get_packed_size
                     (const XmrGenerateSignature *message)
{
  assert(message->base.descriptor == &xmr_generate_signature__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t xmr_generate_signature__pack
                     (const XmrGenerateSignature *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &xmr_generate_signature__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t xmr_generate_signature__pack_to_buffer
                     (const XmrGenerateSignature *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &xmr_generate_signature__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
XmrGenerateSignature *
       xmr_generate_signature__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (XmrGenerateSignature *)
     protobuf_c_message_unpack (&xmr_generate_signature__descriptor,
                                allocator, len, data);
}
void   xmr_generate_signature__free_unpacked
                     (XmrGenerateSignature *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &xmr_generate_signature__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   xmr_generate_signature_ack__init
                     (XmrGenerateSignatureAck         *message)
{
  static XmrGenerateSignatureAck init_value = XMR_GENERATE_SIGNATURE_ACK__INIT;
  *message = init_value;
}
size_t xmr_generate_signature_ack__get_packed_size
                     (const XmrGenerateSignatureAck *message)
{
  assert(message->base.descriptor == &xmr_generate_signature_ack__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t xmr_generate_signature_ack__pack
                     (const XmrGenerateSignatureAck *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &xmr_generate_signature_ack__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t xmr_generate_signature_ack__pack_to_buffer
                     (const XmrGenerateSignatureAck *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &xmr_generate_signature_ack__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
XmrGenerateSignatureAck *
       xmr_generate_signature_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (XmrGenerateSignatureAck *)
     protobuf_c_message_unpack (&xmr_generate_signature_ack__descriptor,
                                allocator, len, data);
}
void   xmr_generate_signature_ack__free_unpacked
                     (XmrGenerateSignatureAck *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &xmr_generate_signature_ack__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   xmr_generate_tx_init__init
                     (XmrGenerateTxInit         *message)
{
  static XmrGenerateTxInit init_value = XMR_GENERATE_TX_INIT__INIT;
  *message = init_value;
}
size_t xmr_generate_tx_init__get_packed_size
                     (const XmrGenerateTxInit *message)
{
  assert(message->base.descriptor == &xmr_generate_tx_init__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t xmr_generate_tx_init__pack
                     (const XmrGenerateTxInit *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &xmr_generate_tx_init__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t xmr_generate_tx_init__pack_to_buffer
                     (const XmrGenerateTxInit *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &xmr_generate_tx_init__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
XmrGenerateTxInit *
       xmr_generate_tx_init__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (XmrGenerateTxInit *)
     protobuf_c_message_unpack (&xmr_generate_tx_init__descriptor,
                                allocator, len, data);
}
void   xmr_generate_tx_init__free_unpacked
                     (XmrGenerateTxInit *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &xmr_generate_tx_init__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   xmr_generate_tx_init_ack__init
                     (XmrGenerateTxInitAck         *message)
{
  static XmrGenerateTxInitAck init_value = XMR_GENERATE_TX_INIT_ACK__INIT;
  *message = init_value;
}
size_t xmr_generate_tx_init_ack__get_packed_size
                     (const XmrGenerateTxInitAck *message)
{
  assert(message->base.descriptor == &xmr_generate_tx_init_ack__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t xmr_generate_tx_init_ack__pack
                     (const XmrGenerateTxInitAck *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &xmr_generate_tx_init_ack__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t xmr_generate_tx_init_ack__pack_to_buffer
                     (const XmrGenerateTxInitAck *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &xmr_generate_tx_init_ack__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
XmrGenerateTxInitAck *
       xmr_generate_tx_init_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (XmrGenerateTxInitAck *)
     protobuf_c_message_unpack (&xmr_generate_tx_init_ack__descriptor,
                                allocator, len, data);
}
void   xmr_generate_tx_init_ack__free_unpacked
                     (XmrGenerateTxInitAck *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &xmr_generate_tx_init_ack__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   xmr_generate_tx_extra__init
                     (XmrGenerateTxExtra         *message)
{
  static XmrGenerateTxExtra init_value = XMR_GENERATE_TX_EXTRA__INIT;
  *message = init_value;
}
size_t xmr_generate_tx_extra__get_packed_size
                     (const XmrGenerateTxExtra *message)
{
  assert(message->base.descriptor == &xmr_generate_tx_extra__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t xmr_generate_tx_extra__pack
                     (const XmrGenerateTxExtra *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &xmr_generate_tx_extra__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t xmr_generate_tx_extra__pack_to_buffer
                     (const XmrGenerateTxExtra *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &xmr_generate_tx_extra__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
XmrGenerateTxExtra *
       xmr_generate_tx_extra__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (XmrGenerateTxExtra *)
     protobuf_c_message_unpack (&xmr_generate_tx_extra__descriptor,
                                allocator, len, data);
}
void   xmr_generate_tx_extra__free_unpacked
                     (XmrGenerateTxExtra *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &xmr_generate_tx_extra__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   xmr_generate_tx_extra_ack__init
                     (XmrGenerateTxExtraAck         *message)
{
  static XmrGenerateTxExtraAck init_value = XMR_GENERATE_TX_EXTRA_ACK__INIT;
  *message = init_value;
}
size_t xmr_generate_tx_extra_ack__get_packed_size
                     (const XmrGenerateTxExtraAck *message)
{
  assert(message->base.descriptor == &xmr_generate_tx_extra_ack__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t xmr_generate_tx_extra_ack__pack
                     (const XmrGenerateTxExtraAck *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &xmr_generate_tx_extra_ack__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t xmr_generate_tx_extra_ack__pack_to_buffer
                     (const XmrGenerateTxExtraAck *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &xmr_generate_tx_extra_ack__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
XmrGenerateTxExtraAck *
       xmr_generate_tx_extra_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (XmrGenerateTxExtraAck *)
     protobuf_c_message_unpack (&xmr_generate_tx_extra_ack__descriptor,
                                allocator, len, data);
}
void   xmr_generate_tx_extra_ack__free_unpacked
                     (XmrGenerateTxExtraAck *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &xmr_generate_tx_extra_ack__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   xmr_generate_tx_vin__init
                     (XmrGenerateTxVin         *message)
{
  static XmrGenerateTxVin init_value = XMR_GENERATE_TX_VIN__INIT;
  *message = init_value;
}
size_t xmr_generate_tx_vin__get_packed_size
                     (const XmrGenerateTxVin *message)
{
  assert(message->base.descriptor == &xmr_generate_tx_vin__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t xmr_generate_tx_vin__pack
                     (const XmrGenerateTxVin *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &xmr_generate_tx_vin__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t xmr_generate_tx_vin__pack_to_buffer
                     (const XmrGenerateTxVin *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &xmr_generate_tx_vin__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
XmrGenerateTxVin *
       xmr_generate_tx_vin__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (XmrGenerateTxVin *)
     protobuf_c_message_unpack (&xmr_generate_tx_vin__descriptor,
                                allocator, len, data);
}
void   xmr_generate_tx_vin__free_unpacked
                     (XmrGenerateTxVin *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &xmr_generate_tx_vin__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   xmr_generate_tx_vin_ack__init
                     (XmrGenerateTxVinAck         *message)
{
  static XmrGenerateTxVinAck init_value = XMR_GENERATE_TX_VIN_ACK__INIT;
  *message = init_value;
}
size_t xmr_generate_tx_vin_ack__get_packed_size
                     (const XmrGenerateTxVinAck *message)
{
  assert(message->base.descriptor == &xmr_generate_tx_vin_ack__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t xmr_generate_tx_vin_ack__pack
                     (const XmrGenerateTxVinAck *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &xmr_generate_tx_vin_ack__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t xmr_generate_tx_vin_ack__pack_to_buffer
                     (const XmrGenerateTxVinAck *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &xmr_generate_tx_vin_ack__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
XmrGenerateTxVinAck *
       xmr_generate_tx_vin_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (XmrGenerateTxVinAck *)
     protobuf_c_message_unpack (&xmr_generate_tx_vin_ack__descriptor,
                                allocator, len, data);
}
void   xmr_generate_tx_vin_ack__free_unpacked
                     (XmrGenerateTxVinAck *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &xmr_generate_tx_vin_ack__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   xmr_generate_tx_vout__init
                     (XmrGenerateTxVout         *message)
{
  static XmrGenerateTxVout init_value = XMR_GENERATE_TX_VOUT__INIT;
  *message = init_value;
}
size_t xmr_generate_tx_vout__get_packed_size
                     (const XmrGenerateTxVout *message)
{
  assert(message->base.descriptor == &xmr_generate_tx_vout__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t xmr_generate_tx_vout__pack
                     (const XmrGenerateTxVout *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &xmr_generate_tx_vout__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t xmr_generate_tx_vout__pack_to_buffer
                     (const XmrGenerateTxVout *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &xmr_generate_tx_vout__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
XmrGenerateTxVout *
       xmr_generate_tx_vout__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (XmrGenerateTxVout *)
     protobuf_c_message_unpack (&xmr_generate_tx_vout__descriptor,
                                allocator, len, data);
}
void   xmr_generate_tx_vout__free_unpacked
                     (XmrGenerateTxVout *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &xmr_generate_tx_vout__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   xmr_generate_tx_vout_ack__init
                     (XmrGenerateTxVoutAck         *message)
{
  static XmrGenerateTxVoutAck init_value = XMR_GENERATE_TX_VOUT_ACK__INIT;
  *message = init_value;
}
size_t xmr_generate_tx_vout_ack__get_packed_size
                     (const XmrGenerateTxVoutAck *message)
{
  assert(message->base.descriptor == &xmr_generate_tx_vout_ack__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t xmr_generate_tx_vout_ack__pack
                     (const XmrGenerateTxVoutAck *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &xmr_generate_tx_vout_ack__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t xmr_generate_tx_vout_ack__pack_to_buffer
                     (const XmrGenerateTxVoutAck *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &xmr_generate_tx_vout_ack__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
XmrGenerateTxVoutAck *
       xmr_generate_tx_vout_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (XmrGenerateTxVoutAck *)
     protobuf_c_message_unpack (&xmr_generate_tx_vout_ack__descriptor,
                                allocator, len, data);
}
void   xmr_generate_tx_vout_ack__free_unpacked
                     (XmrGenerateTxVoutAck *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &xmr_generate_tx_vout_ack__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
#define initialize__field_descriptors NULL
#define initialize__field_indices_by_name NULL
#define initialize__number_ranges NULL
const ProtobufCMessageDescriptor initialize__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Initialize",
  "Initialize",
  "Initialize",
  "",
  sizeof(Initialize),
  0,
  initialize__field_descriptors,
  initialize__field_indices_by_name,
  0,  initialize__number_ranges,
  (ProtobufCMessageInit) initialize__init,
  NULL,NULL,NULL    /* reserved[123] */
};
#define get_features__field_descriptors NULL
#define get_features__field_indices_by_name NULL
#define get_features__number_ranges NULL
const ProtobufCMessageDescriptor get_features__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "GetFeatures",
  "GetFeatures",
  "GetFeatures",
  "",
  sizeof(GetFeatures),
  0,
  get_features__field_descriptors,
  get_features__field_indices_by_name,
  0,  get_features__number_ranges,
  (ProtobufCMessageInit) get_features__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor features__field_descriptors[17] =
{
  {
    "vendor",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(Features, vendor),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "major_version",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(Features, has_major_version),
    offsetof(Features, major_version),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "minor_version",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(Features, has_minor_version),
    offsetof(Features, minor_version),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "patch_version",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(Features, has_patch_version),
    offsetof(Features, patch_version),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "bootloader_mode",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(Features, has_bootloader_mode),
    offsetof(Features, bootloader_mode),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "device_id",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(Features, device_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "pin_protection",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(Features, has_pin_protection),
    offsetof(Features, pin_protection),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "passphrase_protection",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(Features, has_passphrase_protection),
    offsetof(Features, passphrase_protection),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "language",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(Features, language),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "label",
    10,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(Features, label),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "coins",
    11,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Features, n_coins),
    offsetof(Features, coins),
    &coin_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "initialized",
    12,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(Features, has_initialized),
    offsetof(Features, initialized),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "revision",
    13,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(Features, has_revision),
    offsetof(Features, revision),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "bootloader_hash",
    14,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(Features, has_bootloader_hash),
    offsetof(Features, bootloader_hash),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "imported",
    15,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(Features, has_imported),
    offsetof(Features, imported),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "pin_cached",
    16,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(Features, has_pin_cached),
    offsetof(Features, pin_cached),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "passphrase_cached",
    17,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(Features, has_passphrase_cached),
    offsetof(Features, passphrase_cached),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned features__field_indices_by_name[] = {
  13,   /* field[13] = bootloader_hash */
  4,   /* field[4] = bootloader_mode */
  10,   /* field[10] = coins */
  5,   /* field[5] = device_id */
  14,   /* field[14] = imported */
  11,   /* field[11] = initialized */
  9,   /* field[9] = label */
  8,   /* field[8] = language */
  1,   /* field[1] = major_version */
  2,   /* field[2] = minor_version */
  16,   /* field[16] = passphrase_cached */
  7,   /* field[7] = passphrase_protection */
  3,   /* field[3] = patch_version */
  15,   /* field[15] = pin_cached */
  6,   /* field[6] = pin_protection */
  12,   /* field[12] = revision */
  0,   /* field[0] = vendor */
};
static const ProtobufCIntRange features__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 17 }
};
const ProtobufCMessageDescriptor features__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Features",
  "Features",
  "Features",
  "",
  sizeof(Features),
  17,
  features__field_descriptors,
  features__field_indices_by_name,
  1,  features__number_ranges,
  (ProtobufCMessageInit) features__init,
  NULL,NULL,NULL    /* reserved[123] */
};
#define clear_session__field_descriptors NULL
#define clear_session__field_indices_by_name NULL
#define clear_session__number_ranges NULL
const ProtobufCMessageDescriptor clear_session__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "ClearSession",
  "ClearSession",
  "ClearSession",
  "",
  sizeof(ClearSession),
  0,
  clear_session__field_descriptors,
  clear_session__field_indices_by_name,
  0,  clear_session__number_ranges,
  (ProtobufCMessageInit) clear_session__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor apply_settings__field_descriptors[4] =
{
  {
    "language",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ApplySettings, language),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "label",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ApplySettings, label),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "use_passphrase",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(ApplySettings, has_use_passphrase),
    offsetof(ApplySettings, use_passphrase),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "homescreen",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(ApplySettings, has_homescreen),
    offsetof(ApplySettings, homescreen),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned apply_settings__field_indices_by_name[] = {
  3,   /* field[3] = homescreen */
  1,   /* field[1] = label */
  0,   /* field[0] = language */
  2,   /* field[2] = use_passphrase */
};
static const ProtobufCIntRange apply_settings__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor apply_settings__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "ApplySettings",
  "ApplySettings",
  "ApplySettings",
  "",
  sizeof(ApplySettings),
  4,
  apply_settings__field_descriptors,
  apply_settings__field_indices_by_name,
  1,  apply_settings__number_ranges,
  (ProtobufCMessageInit) apply_settings__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor change_pin__field_descriptors[1] =
{
  {
    "remove",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(ChangePin, has_remove),
    offsetof(ChangePin, remove),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned change_pin__field_indices_by_name[] = {
  0,   /* field[0] = remove */
};
static const ProtobufCIntRange change_pin__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor change_pin__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "ChangePin",
  "ChangePin",
  "ChangePin",
  "",
  sizeof(ChangePin),
  1,
  change_pin__field_descriptors,
  change_pin__field_indices_by_name,
  1,  change_pin__number_ranges,
  (ProtobufCMessageInit) change_pin__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor ping__field_descriptors[4] =
{
  {
    "message",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(Ping, message),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "button_protection",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(Ping, has_button_protection),
    offsetof(Ping, button_protection),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "pin_protection",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(Ping, has_pin_protection),
    offsetof(Ping, pin_protection),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "passphrase_protection",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(Ping, has_passphrase_protection),
    offsetof(Ping, passphrase_protection),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned ping__field_indices_by_name[] = {
  1,   /* field[1] = button_protection */
  0,   /* field[0] = message */
  3,   /* field[3] = passphrase_protection */
  2,   /* field[2] = pin_protection */
};
static const ProtobufCIntRange ping__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor ping__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Ping",
  "Ping",
  "Ping",
  "",
  sizeof(Ping),
  4,
  ping__field_descriptors,
  ping__field_indices_by_name,
  1,  ping__number_ranges,
  (ProtobufCMessageInit) ping__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor success__field_descriptors[1] =
{
  {
    "message",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(Success, message),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned success__field_indices_by_name[] = {
  0,   /* field[0] = message */
};
static const ProtobufCIntRange success__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor success__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Success",
  "Success",
  "Success",
  "",
  sizeof(Success),
  1,
  success__field_descriptors,
  success__field_indices_by_name,
  1,  success__number_ranges,
  (ProtobufCMessageInit) success__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor failure__field_descriptors[2] =
{
  {
    "code",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(Failure, has_code),
    offsetof(Failure, code),
    &failure_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "message",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(Failure, message),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned failure__field_indices_by_name[] = {
  0,   /* field[0] = code */
  1,   /* field[1] = message */
};
static const ProtobufCIntRange failure__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor failure__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Failure",
  "Failure",
  "Failure",
  "",
  sizeof(Failure),
  2,
  failure__field_descriptors,
  failure__field_indices_by_name,
  1,  failure__number_ranges,
  (ProtobufCMessageInit) failure__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor button_request__field_descriptors[2] =
{
  {
    "code",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(ButtonRequest, has_code),
    offsetof(ButtonRequest, code),
    &button_request_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "data",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ButtonRequest, data),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned button_request__field_indices_by_name[] = {
  0,   /* field[0] = code */
  1,   /* field[1] = data */
};
static const ProtobufCIntRange button_request__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor button_request__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "ButtonRequest",
  "ButtonRequest",
  "ButtonRequest",
  "",
  sizeof(ButtonRequest),
  2,
  button_request__field_descriptors,
  button_request__field_indices_by_name,
  1,  button_request__number_ranges,
  (ProtobufCMessageInit) button_request__init,
  NULL,NULL,NULL    /* reserved[123] */
};
#define button_ack__field_descriptors NULL
#define button_ack__field_indices_by_name NULL
#define button_ack__number_ranges NULL
const ProtobufCMessageDescriptor button_ack__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "ButtonAck",
  "ButtonAck",
  "ButtonAck",
  "",
  sizeof(ButtonAck),
  0,
  button_ack__field_descriptors,
  button_ack__field_indices_by_name,
  0,  button_ack__number_ranges,
  (ProtobufCMessageInit) button_ack__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor pin_matrix_request__field_descriptors[1] =
{
  {
    "type",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(PinMatrixRequest, has_type),
    offsetof(PinMatrixRequest, type),
    &pin_matrix_request_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned pin_matrix_request__field_indices_by_name[] = {
  0,   /* field[0] = type */
};
static const ProtobufCIntRange pin_matrix_request__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor pin_matrix_request__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "PinMatrixRequest",
  "PinMatrixRequest",
  "PinMatrixRequest",
  "",
  sizeof(PinMatrixRequest),
  1,
  pin_matrix_request__field_descriptors,
  pin_matrix_request__field_indices_by_name,
  1,  pin_matrix_request__number_ranges,
  (ProtobufCMessageInit) pin_matrix_request__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor pin_matrix_ack__field_descriptors[1] =
{
  {
    "pin",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(PinMatrixAck, pin),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned pin_matrix_ack__field_indices_by_name[] = {
  0,   /* field[0] = pin */
};
static const ProtobufCIntRange pin_matrix_ack__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor pin_matrix_ack__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "PinMatrixAck",
  "PinMatrixAck",
  "PinMatrixAck",
  "",
  sizeof(PinMatrixAck),
  1,
  pin_matrix_ack__field_descriptors,
  pin_matrix_ack__field_indices_by_name,
  1,  pin_matrix_ack__number_ranges,
  (ProtobufCMessageInit) pin_matrix_ack__init,
  NULL,NULL,NULL    /* reserved[123] */
};
#define cancel__field_descriptors NULL
#define cancel__field_indices_by_name NULL
#define cancel__number_ranges NULL
const ProtobufCMessageDescriptor cancel__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Cancel",
  "Cancel",
  "Cancel",
  "",
  sizeof(Cancel),
  0,
  cancel__field_descriptors,
  cancel__field_indices_by_name,
  0,  cancel__number_ranges,
  (ProtobufCMessageInit) cancel__init,
  NULL,NULL,NULL    /* reserved[123] */
};
#define passphrase_request__field_descriptors NULL
#define passphrase_request__field_indices_by_name NULL
#define passphrase_request__number_ranges NULL
const ProtobufCMessageDescriptor passphrase_request__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "PassphraseRequest",
  "PassphraseRequest",
  "PassphraseRequest",
  "",
  sizeof(PassphraseRequest),
  0,
  passphrase_request__field_descriptors,
  passphrase_request__field_indices_by_name,
  0,  passphrase_request__number_ranges,
  (ProtobufCMessageInit) passphrase_request__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor passphrase_ack__field_descriptors[1] =
{
  {
    "passphrase",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(PassphraseAck, passphrase),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned passphrase_ack__field_indices_by_name[] = {
  0,   /* field[0] = passphrase */
};
static const ProtobufCIntRange passphrase_ack__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor passphrase_ack__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "PassphraseAck",
  "PassphraseAck",
  "PassphraseAck",
  "",
  sizeof(PassphraseAck),
  1,
  passphrase_ack__field_descriptors,
  passphrase_ack__field_indices_by_name,
  1,  passphrase_ack__number_ranges,
  (ProtobufCMessageInit) passphrase_ack__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor get_entropy__field_descriptors[1] =
{
  {
    "size",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(GetEntropy, size),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned get_entropy__field_indices_by_name[] = {
  0,   /* field[0] = size */
};
static const ProtobufCIntRange get_entropy__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor get_entropy__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "GetEntropy",
  "GetEntropy",
  "GetEntropy",
  "",
  sizeof(GetEntropy),
  1,
  get_entropy__field_descriptors,
  get_entropy__field_indices_by_name,
  1,  get_entropy__number_ranges,
  (ProtobufCMessageInit) get_entropy__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor entropy__field_descriptors[1] =
{
  {
    "entropy",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(Entropy, entropy),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned entropy__field_indices_by_name[] = {
  0,   /* field[0] = entropy */
};
static const ProtobufCIntRange entropy__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor entropy__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Entropy",
  "Entropy",
  "Entropy",
  "",
  sizeof(Entropy),
  1,
  entropy__field_descriptors,
  entropy__field_indices_by_name,
  1,  entropy__number_ranges,
  (ProtobufCMessageInit) entropy__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor get_public_key__field_descriptors[3] =
{
  {
    "address_n",
    1,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(GetPublicKey, n_address_n),
    offsetof(GetPublicKey, address_n),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "ecdsa_curve_name",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GetPublicKey, ecdsa_curve_name),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "show_display",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(GetPublicKey, has_show_display),
    offsetof(GetPublicKey, show_display),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned get_public_key__field_indices_by_name[] = {
  0,   /* field[0] = address_n */
  1,   /* field[1] = ecdsa_curve_name */
  2,   /* field[2] = show_display */
};
static const ProtobufCIntRange get_public_key__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor get_public_key__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "GetPublicKey",
  "GetPublicKey",
  "GetPublicKey",
  "",
  sizeof(GetPublicKey),
  3,
  get_public_key__field_descriptors,
  get_public_key__field_indices_by_name,
  1,  get_public_key__number_ranges,
  (ProtobufCMessageInit) get_public_key__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor public_key__field_descriptors[2] =
{
  {
    "node",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(PublicKey, node),
    &hdnode_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "xpub",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(PublicKey, xpub),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned public_key__field_indices_by_name[] = {
  0,   /* field[0] = node */
  1,   /* field[1] = xpub */
};
static const ProtobufCIntRange public_key__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor public_key__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "PublicKey",
  "PublicKey",
  "PublicKey",
  "",
  sizeof(PublicKey),
  2,
  public_key__field_descriptors,
  public_key__field_indices_by_name,
  1,  public_key__number_ranges,
  (ProtobufCMessageInit) public_key__init,
  NULL,NULL,NULL    /* reserved[123] */
};
char get_address__coin_name__default_value[] = "Bitcoin";
static const ProtobufCFieldDescriptor get_address__field_descriptors[4] =
{
  {
    "address_n",
    1,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(GetAddress, n_address_n),
    offsetof(GetAddress, address_n),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "coin_name",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GetAddress, coin_name),
    NULL,
    &get_address__coin_name__default_value,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "show_display",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(GetAddress, has_show_display),
    offsetof(GetAddress, show_display),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "multisig",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GetAddress, multisig),
    &multisig_redeem_script_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned get_address__field_indices_by_name[] = {
  0,   /* field[0] = address_n */
  1,   /* field[1] = coin_name */
  3,   /* field[3] = multisig */
  2,   /* field[2] = show_display */
};
static const ProtobufCIntRange get_address__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor get_address__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "GetAddress",
  "GetAddress",
  "GetAddress",
  "",
  sizeof(GetAddress),
  4,
  get_address__field_descriptors,
  get_address__field_indices_by_name,
  1,  get_address__number_ranges,
  (ProtobufCMessageInit) get_address__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor ethereum_get_address__field_descriptors[2] =
{
  {
    "address_n",
    1,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(EthereumGetAddress, n_address_n),
    offsetof(EthereumGetAddress, address_n),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "show_display",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(EthereumGetAddress, has_show_display),
    offsetof(EthereumGetAddress, show_display),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned ethereum_get_address__field_indices_by_name[] = {
  0,   /* field[0] = address_n */
  1,   /* field[1] = show_display */
};
static const ProtobufCIntRange ethereum_get_address__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor ethereum_get_address__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "EthereumGetAddress",
  "EthereumGetAddress",
  "EthereumGetAddress",
  "",
  sizeof(EthereumGetAddress),
  2,
  ethereum_get_address__field_descriptors,
  ethereum_get_address__field_indices_by_name,
  1,  ethereum_get_address__number_ranges,
  (ProtobufCMessageInit) ethereum_get_address__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor address__field_descriptors[1] =
{
  {
    "address",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(Address, address),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned address__field_indices_by_name[] = {
  0,   /* field[0] = address */
};
static const ProtobufCIntRange address__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor address__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Address",
  "Address",
  "Address",
  "",
  sizeof(Address),
  1,
  address__field_descriptors,
  address__field_indices_by_name,
  1,  address__number_ranges,
  (ProtobufCMessageInit) address__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor ethereum_address__field_descriptors[1] =
{
  {
    "address",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(EthereumAddress, address),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned ethereum_address__field_indices_by_name[] = {
  0,   /* field[0] = address */
};
static const ProtobufCIntRange ethereum_address__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor ethereum_address__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "EthereumAddress",
  "EthereumAddress",
  "EthereumAddress",
  "",
  sizeof(EthereumAddress),
  1,
  ethereum_address__field_descriptors,
  ethereum_address__field_indices_by_name,
  1,  ethereum_address__number_ranges,
  (ProtobufCMessageInit) ethereum_address__init,
  NULL,NULL,NULL    /* reserved[123] */
};
#define wipe_device__field_descriptors NULL
#define wipe_device__field_indices_by_name NULL
#define wipe_device__number_ranges NULL
const ProtobufCMessageDescriptor wipe_device__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "WipeDevice",
  "WipeDevice",
  "WipeDevice",
  "",
  sizeof(WipeDevice),
  0,
  wipe_device__field_descriptors,
  wipe_device__field_indices_by_name,
  0,  wipe_device__number_ranges,
  (ProtobufCMessageInit) wipe_device__init,
  NULL,NULL,NULL    /* reserved[123] */
};
char load_device__language__default_value[] = "english";
static const ProtobufCFieldDescriptor load_device__field_descriptors[7] =
{
  {
    "mnemonic",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(LoadDevice, mnemonic),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "node",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(LoadDevice, node),
    &hdnode_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "pin",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(LoadDevice, pin),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "passphrase_protection",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(LoadDevice, has_passphrase_protection),
    offsetof(LoadDevice, passphrase_protection),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "language",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(LoadDevice, language),
    NULL,
    &load_device__language__default_value,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "label",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(LoadDevice, label),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "skip_checksum",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(LoadDevice, has_skip_checksum),
    offsetof(LoadDevice, skip_checksum),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned load_device__field_indices_by_name[] = {
  5,   /* field[5] = label */
  4,   /* field[4] = language */
  0,   /* field[0] = mnemonic */
  1,   /* field[1] = node */
  3,   /* field[3] = passphrase_protection */
  2,   /* field[2] = pin */
  6,   /* field[6] = skip_checksum */
};
static const ProtobufCIntRange load_device__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 7 }
};
const ProtobufCMessageDescriptor load_device__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "LoadDevice",
  "LoadDevice",
  "LoadDevice",
  "",
  sizeof(LoadDevice),
  7,
  load_device__field_descriptors,
  load_device__field_indices_by_name,
  1,  load_device__number_ranges,
  (ProtobufCMessageInit) load_device__init,
  NULL,NULL,NULL    /* reserved[123] */
};
char reset_device__language__default_value[] = "english";
static const uint32_t reset_device__strength__default_value = 256u;
static const ProtobufCFieldDescriptor reset_device__field_descriptors[6] =
{
  {
    "display_random",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(ResetDevice, has_display_random),
    offsetof(ResetDevice, display_random),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "strength",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ResetDevice, has_strength),
    offsetof(ResetDevice, strength),
    NULL,
    &reset_device__strength__default_value,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "passphrase_protection",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(ResetDevice, has_passphrase_protection),
    offsetof(ResetDevice, passphrase_protection),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "pin_protection",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(ResetDevice, has_pin_protection),
    offsetof(ResetDevice, pin_protection),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "language",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ResetDevice, language),
    NULL,
    &reset_device__language__default_value,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "label",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ResetDevice, label),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned reset_device__field_indices_by_name[] = {
  0,   /* field[0] = display_random */
  5,   /* field[5] = label */
  4,   /* field[4] = language */
  2,   /* field[2] = passphrase_protection */
  3,   /* field[3] = pin_protection */
  1,   /* field[1] = strength */
};
static const ProtobufCIntRange reset_device__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 6 }
};
const ProtobufCMessageDescriptor reset_device__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "ResetDevice",
  "ResetDevice",
  "ResetDevice",
  "",
  sizeof(ResetDevice),
  6,
  reset_device__field_descriptors,
  reset_device__field_indices_by_name,
  1,  reset_device__number_ranges,
  (ProtobufCMessageInit) reset_device__init,
  NULL,NULL,NULL    /* reserved[123] */
};
#define entropy_request__field_descriptors NULL
#define entropy_request__field_indices_by_name NULL
#define entropy_request__number_ranges NULL
const ProtobufCMessageDescriptor entropy_request__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "EntropyRequest",
  "EntropyRequest",
  "EntropyRequest",
  "",
  sizeof(EntropyRequest),
  0,
  entropy_request__field_descriptors,
  entropy_request__field_indices_by_name,
  0,  entropy_request__number_ranges,
  (ProtobufCMessageInit) entropy_request__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor entropy_ack__field_descriptors[1] =
{
  {
    "entropy",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(EntropyAck, has_entropy),
    offsetof(EntropyAck, entropy),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned entropy_ack__field_indices_by_name[] = {
  0,   /* field[0] = entropy */
};
static const ProtobufCIntRange entropy_ack__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor entropy_ack__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "EntropyAck",
  "EntropyAck",
  "EntropyAck",
  "",
  sizeof(EntropyAck),
  1,
  entropy_ack__field_descriptors,
  entropy_ack__field_indices_by_name,
  1,  entropy_ack__number_ranges,
  (ProtobufCMessageInit) entropy_ack__init,
  NULL,NULL,NULL    /* reserved[123] */
};
char recovery_device__language__default_value[] = "english";
static const ProtobufCFieldDescriptor recovery_device__field_descriptors[6] =
{
  {
    "word_count",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(RecoveryDevice, has_word_count),
    offsetof(RecoveryDevice, word_count),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "passphrase_protection",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(RecoveryDevice, has_passphrase_protection),
    offsetof(RecoveryDevice, passphrase_protection),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "pin_protection",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(RecoveryDevice, has_pin_protection),
    offsetof(RecoveryDevice, pin_protection),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "language",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(RecoveryDevice, language),
    NULL,
    &recovery_device__language__default_value,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "label",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(RecoveryDevice, label),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "enforce_wordlist",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(RecoveryDevice, has_enforce_wordlist),
    offsetof(RecoveryDevice, enforce_wordlist),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned recovery_device__field_indices_by_name[] = {
  5,   /* field[5] = enforce_wordlist */
  4,   /* field[4] = label */
  3,   /* field[3] = language */
  1,   /* field[1] = passphrase_protection */
  2,   /* field[2] = pin_protection */
  0,   /* field[0] = word_count */
};
static const ProtobufCIntRange recovery_device__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 6 }
};
const ProtobufCMessageDescriptor recovery_device__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "RecoveryDevice",
  "RecoveryDevice",
  "RecoveryDevice",
  "",
  sizeof(RecoveryDevice),
  6,
  recovery_device__field_descriptors,
  recovery_device__field_indices_by_name,
  1,  recovery_device__number_ranges,
  (ProtobufCMessageInit) recovery_device__init,
  NULL,NULL,NULL    /* reserved[123] */
};
#define word_request__field_descriptors NULL
#define word_request__field_indices_by_name NULL
#define word_request__number_ranges NULL
const ProtobufCMessageDescriptor word_request__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "WordRequest",
  "WordRequest",
  "WordRequest",
  "",
  sizeof(WordRequest),
  0,
  word_request__field_descriptors,
  word_request__field_indices_by_name,
  0,  word_request__number_ranges,
  (ProtobufCMessageInit) word_request__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor word_ack__field_descriptors[1] =
{
  {
    "word",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(WordAck, word),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned word_ack__field_indices_by_name[] = {
  0,   /* field[0] = word */
};
static const ProtobufCIntRange word_ack__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor word_ack__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "WordAck",
  "WordAck",
  "WordAck",
  "",
  sizeof(WordAck),
  1,
  word_ack__field_descriptors,
  word_ack__field_indices_by_name,
  1,  word_ack__number_ranges,
  (ProtobufCMessageInit) word_ack__init,
  NULL,NULL,NULL    /* reserved[123] */
};
char sign_message__coin_name__default_value[] = "Bitcoin";
static const ProtobufCFieldDescriptor sign_message__field_descriptors[3] =
{
  {
    "address_n",
    1,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(SignMessage, n_address_n),
    offsetof(SignMessage, address_n),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "message",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(SignMessage, message),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "coin_name",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(SignMessage, coin_name),
    NULL,
    &sign_message__coin_name__default_value,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned sign_message__field_indices_by_name[] = {
  0,   /* field[0] = address_n */
  2,   /* field[2] = coin_name */
  1,   /* field[1] = message */
};
static const ProtobufCIntRange sign_message__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor sign_message__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "SignMessage",
  "SignMessage",
  "SignMessage",
  "",
  sizeof(SignMessage),
  3,
  sign_message__field_descriptors,
  sign_message__field_indices_by_name,
  1,  sign_message__number_ranges,
  (ProtobufCMessageInit) sign_message__init,
  NULL,NULL,NULL    /* reserved[123] */
};
char verify_message__coin_name__default_value[] = "Bitcoin";
static const ProtobufCFieldDescriptor verify_message__field_descriptors[4] =
{
  {
    "address",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(VerifyMessage, address),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "signature",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(VerifyMessage, has_signature),
    offsetof(VerifyMessage, signature),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "message",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(VerifyMessage, has_message),
    offsetof(VerifyMessage, message),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "coin_name",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(VerifyMessage, coin_name),
    NULL,
    &verify_message__coin_name__default_value,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned verify_message__field_indices_by_name[] = {
  0,   /* field[0] = address */
  3,   /* field[3] = coin_name */
  2,   /* field[2] = message */
  1,   /* field[1] = signature */
};
static const ProtobufCIntRange verify_message__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor verify_message__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "VerifyMessage",
  "VerifyMessage",
  "VerifyMessage",
  "",
  sizeof(VerifyMessage),
  4,
  verify_message__field_descriptors,
  verify_message__field_indices_by_name,
  1,  verify_message__number_ranges,
  (ProtobufCMessageInit) verify_message__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor message_signature__field_descriptors[2] =
{
  {
    "address",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(MessageSignature, address),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "signature",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(MessageSignature, has_signature),
    offsetof(MessageSignature, signature),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned message_signature__field_indices_by_name[] = {
  0,   /* field[0] = address */
  1,   /* field[1] = signature */
};
static const ProtobufCIntRange message_signature__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor message_signature__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "MessageSignature",
  "MessageSignature",
  "MessageSignature",
  "",
  sizeof(MessageSignature),
  2,
  message_signature__field_descriptors,
  message_signature__field_indices_by_name,
  1,  message_signature__number_ranges,
  (ProtobufCMessageInit) message_signature__init,
  NULL,NULL,NULL    /* reserved[123] */
};
char encrypt_message__coin_name__default_value[] = "Bitcoin";
static const ProtobufCFieldDescriptor encrypt_message__field_descriptors[5] =
{
  {
    "pubkey",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(EncryptMessage, has_pubkey),
    offsetof(EncryptMessage, pubkey),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "message",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(EncryptMessage, has_message),
    offsetof(EncryptMessage, message),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "display_only",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(EncryptMessage, has_display_only),
    offsetof(EncryptMessage, display_only),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "address_n",
    4,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(EncryptMessage, n_address_n),
    offsetof(EncryptMessage, address_n),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "coin_name",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(EncryptMessage, coin_name),
    NULL,
    &encrypt_message__coin_name__default_value,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned encrypt_message__field_indices_by_name[] = {
  3,   /* field[3] = address_n */
  4,   /* field[4] = coin_name */
  2,   /* field[2] = display_only */
  1,   /* field[1] = message */
  0,   /* field[0] = pubkey */
};
static const ProtobufCIntRange encrypt_message__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 5 }
};
const ProtobufCMessageDescriptor encrypt_message__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "EncryptMessage",
  "EncryptMessage",
  "EncryptMessage",
  "",
  sizeof(EncryptMessage),
  5,
  encrypt_message__field_descriptors,
  encrypt_message__field_indices_by_name,
  1,  encrypt_message__number_ranges,
  (ProtobufCMessageInit) encrypt_message__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor encrypted_message__field_descriptors[3] =
{
  {
    "nonce",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(EncryptedMessage, has_nonce),
    offsetof(EncryptedMessage, nonce),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "message",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(EncryptedMessage, has_message),
    offsetof(EncryptedMessage, message),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "hmac",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(EncryptedMessage, has_hmac),
    offsetof(EncryptedMessage, hmac),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned encrypted_message__field_indices_by_name[] = {
  2,   /* field[2] = hmac */
  1,   /* field[1] = message */
  0,   /* field[0] = nonce */
};
static const ProtobufCIntRange encrypted_message__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor encrypted_message__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "EncryptedMessage",
  "EncryptedMessage",
  "EncryptedMessage",
  "",
  sizeof(EncryptedMessage),
  3,
  encrypted_message__field_descriptors,
  encrypted_message__field_indices_by_name,
  1,  encrypted_message__number_ranges,
  (ProtobufCMessageInit) encrypted_message__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor decrypt_message__field_descriptors[4] =
{
  {
    "address_n",
    1,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(DecryptMessage, n_address_n),
    offsetof(DecryptMessage, address_n),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "nonce",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(DecryptMessage, has_nonce),
    offsetof(DecryptMessage, nonce),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "message",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(DecryptMessage, has_message),
    offsetof(DecryptMessage, message),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "hmac",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(DecryptMessage, has_hmac),
    offsetof(DecryptMessage, hmac),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned decrypt_message__field_indices_by_name[] = {
  0,   /* field[0] = address_n */
  3,   /* field[3] = hmac */
  2,   /* field[2] = message */
  1,   /* field[1] = nonce */
};
static const ProtobufCIntRange decrypt_message__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor decrypt_message__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "DecryptMessage",
  "DecryptMessage",
  "DecryptMessage",
  "",
  sizeof(DecryptMessage),
  4,
  decrypt_message__field_descriptors,
  decrypt_message__field_indices_by_name,
  1,  decrypt_message__number_ranges,
  (ProtobufCMessageInit) decrypt_message__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor decrypted_message__field_descriptors[2] =
{
  {
    "message",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(DecryptedMessage, has_message),
    offsetof(DecryptedMessage, message),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "address",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(DecryptedMessage, address),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned decrypted_message__field_indices_by_name[] = {
  1,   /* field[1] = address */
  0,   /* field[0] = message */
};
static const ProtobufCIntRange decrypted_message__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor decrypted_message__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "DecryptedMessage",
  "DecryptedMessage",
  "DecryptedMessage",
  "",
  sizeof(DecryptedMessage),
  2,
  decrypted_message__field_descriptors,
  decrypted_message__field_indices_by_name,
  1,  decrypted_message__number_ranges,
  (ProtobufCMessageInit) decrypted_message__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor cipher_key_value__field_descriptors[7] =
{
  {
    "address_n",
    1,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(CipherKeyValue, n_address_n),
    offsetof(CipherKeyValue, address_n),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "key",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(CipherKeyValue, key),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "value",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(CipherKeyValue, has_value),
    offsetof(CipherKeyValue, value),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "encrypt",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(CipherKeyValue, has_encrypt),
    offsetof(CipherKeyValue, encrypt),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "ask_on_encrypt",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(CipherKeyValue, has_ask_on_encrypt),
    offsetof(CipherKeyValue, ask_on_encrypt),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "ask_on_decrypt",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(CipherKeyValue, has_ask_on_decrypt),
    offsetof(CipherKeyValue, ask_on_decrypt),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "iv",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(CipherKeyValue, has_iv),
    offsetof(CipherKeyValue, iv),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned cipher_key_value__field_indices_by_name[] = {
  0,   /* field[0] = address_n */
  5,   /* field[5] = ask_on_decrypt */
  4,   /* field[4] = ask_on_encrypt */
  3,   /* field[3] = encrypt */
  6,   /* field[6] = iv */
  1,   /* field[1] = key */
  2,   /* field[2] = value */
};
static const ProtobufCIntRange cipher_key_value__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 7 }
};
const ProtobufCMessageDescriptor cipher_key_value__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "CipherKeyValue",
  "CipherKeyValue",
  "CipherKeyValue",
  "",
  sizeof(CipherKeyValue),
  7,
  cipher_key_value__field_descriptors,
  cipher_key_value__field_indices_by_name,
  1,  cipher_key_value__number_ranges,
  (ProtobufCMessageInit) cipher_key_value__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor ciphered_key_value__field_descriptors[1] =
{
  {
    "value",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(CipheredKeyValue, has_value),
    offsetof(CipheredKeyValue, value),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned ciphered_key_value__field_indices_by_name[] = {
  0,   /* field[0] = value */
};
static const ProtobufCIntRange ciphered_key_value__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor ciphered_key_value__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "CipheredKeyValue",
  "CipheredKeyValue",
  "CipheredKeyValue",
  "",
  sizeof(CipheredKeyValue),
  1,
  ciphered_key_value__field_descriptors,
  ciphered_key_value__field_indices_by_name,
  1,  ciphered_key_value__number_ranges,
  (ProtobufCMessageInit) ciphered_key_value__init,
  NULL,NULL,NULL    /* reserved[123] */
};
char estimate_tx_size__coin_name__default_value[] = "Bitcoin";
static const ProtobufCFieldDescriptor estimate_tx_size__field_descriptors[3] =
{
  {
    "outputs_count",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(EstimateTxSize, outputs_count),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "inputs_count",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(EstimateTxSize, inputs_count),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "coin_name",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(EstimateTxSize, coin_name),
    NULL,
    &estimate_tx_size__coin_name__default_value,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned estimate_tx_size__field_indices_by_name[] = {
  2,   /* field[2] = coin_name */
  1,   /* field[1] = inputs_count */
  0,   /* field[0] = outputs_count */
};
static const ProtobufCIntRange estimate_tx_size__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor estimate_tx_size__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "EstimateTxSize",
  "EstimateTxSize",
  "EstimateTxSize",
  "",
  sizeof(EstimateTxSize),
  3,
  estimate_tx_size__field_descriptors,
  estimate_tx_size__field_indices_by_name,
  1,  estimate_tx_size__number_ranges,
  (ProtobufCMessageInit) estimate_tx_size__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor tx_size__field_descriptors[1] =
{
  {
    "tx_size",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(TxSize, has_tx_size),
    offsetof(TxSize, tx_size),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned tx_size__field_indices_by_name[] = {
  0,   /* field[0] = tx_size */
};
static const ProtobufCIntRange tx_size__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor tx_size__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "TxSize",
  "TxSize",
  "TxSize",
  "",
  sizeof(TxSize),
  1,
  tx_size__field_descriptors,
  tx_size__field_indices_by_name,
  1,  tx_size__number_ranges,
  (ProtobufCMessageInit) tx_size__init,
  NULL,NULL,NULL    /* reserved[123] */
};
char sign_tx__coin_name__default_value[] = "Bitcoin";
static const uint32_t sign_tx__version__default_value = 1u;
static const uint32_t sign_tx__lock_time__default_value = 0u;
static const ProtobufCFieldDescriptor sign_tx__field_descriptors[5] =
{
  {
    "outputs_count",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(SignTx, outputs_count),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "inputs_count",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(SignTx, inputs_count),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "coin_name",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(SignTx, coin_name),
    NULL,
    &sign_tx__coin_name__default_value,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "version",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(SignTx, has_version),
    offsetof(SignTx, version),
    NULL,
    &sign_tx__version__default_value,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "lock_time",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(SignTx, has_lock_time),
    offsetof(SignTx, lock_time),
    NULL,
    &sign_tx__lock_time__default_value,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned sign_tx__field_indices_by_name[] = {
  2,   /* field[2] = coin_name */
  1,   /* field[1] = inputs_count */
  4,   /* field[4] = lock_time */
  0,   /* field[0] = outputs_count */
  3,   /* field[3] = version */
};
static const ProtobufCIntRange sign_tx__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 5 }
};
const ProtobufCMessageDescriptor sign_tx__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "SignTx",
  "SignTx",
  "SignTx",
  "",
  sizeof(SignTx),
  5,
  sign_tx__field_descriptors,
  sign_tx__field_indices_by_name,
  1,  sign_tx__number_ranges,
  (ProtobufCMessageInit) sign_tx__init,
  NULL,NULL,NULL    /* reserved[123] */
};
char simple_sign_tx__coin_name__default_value[] = "Bitcoin";
static const uint32_t simple_sign_tx__version__default_value = 1u;
static const uint32_t simple_sign_tx__lock_time__default_value = 0u;
static const ProtobufCFieldDescriptor simple_sign_tx__field_descriptors[6] =
{
  {
    "inputs",
    1,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(SimpleSignTx, n_inputs),
    offsetof(SimpleSignTx, inputs),
    &tx_input_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "outputs",
    2,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(SimpleSignTx, n_outputs),
    offsetof(SimpleSignTx, outputs),
    &tx_output_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "transactions",
    3,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(SimpleSignTx, n_transactions),
    offsetof(SimpleSignTx, transactions),
    &transaction_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "coin_name",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(SimpleSignTx, coin_name),
    NULL,
    &simple_sign_tx__coin_name__default_value,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "version",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(SimpleSignTx, has_version),
    offsetof(SimpleSignTx, version),
    NULL,
    &simple_sign_tx__version__default_value,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "lock_time",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(SimpleSignTx, has_lock_time),
    offsetof(SimpleSignTx, lock_time),
    NULL,
    &simple_sign_tx__lock_time__default_value,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned simple_sign_tx__field_indices_by_name[] = {
  3,   /* field[3] = coin_name */
  0,   /* field[0] = inputs */
  5,   /* field[5] = lock_time */
  1,   /* field[1] = outputs */
  2,   /* field[2] = transactions */
  4,   /* field[4] = version */
};
static const ProtobufCIntRange simple_sign_tx__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 6 }
};
const ProtobufCMessageDescriptor simple_sign_tx__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "SimpleSignTx",
  "SimpleSignTx",
  "SimpleSignTx",
  "",
  sizeof(SimpleSignTx),
  6,
  simple_sign_tx__field_descriptors,
  simple_sign_tx__field_indices_by_name,
  1,  simple_sign_tx__number_ranges,
  (ProtobufCMessageInit) simple_sign_tx__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor tx_request__field_descriptors[3] =
{
  {
    "request_type",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(TxRequest, has_request_type),
    offsetof(TxRequest, request_type),
    &request_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "details",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(TxRequest, details),
    &tx_request_details_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "serialized",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(TxRequest, serialized),
    &tx_request_serialized_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned tx_request__field_indices_by_name[] = {
  1,   /* field[1] = details */
  0,   /* field[0] = request_type */
  2,   /* field[2] = serialized */
};
static const ProtobufCIntRange tx_request__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor tx_request__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "TxRequest",
  "TxRequest",
  "TxRequest",
  "",
  sizeof(TxRequest),
  3,
  tx_request__field_descriptors,
  tx_request__field_indices_by_name,
  1,  tx_request__number_ranges,
  (ProtobufCMessageInit) tx_request__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor tx_ack__field_descriptors[1] =
{
  {
    "tx",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(TxAck, tx),
    &transaction_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned tx_ack__field_indices_by_name[] = {
  0,   /* field[0] = tx */
};
static const ProtobufCIntRange tx_ack__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor tx_ack__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "TxAck",
  "TxAck",
  "TxAck",
  "",
  sizeof(TxAck),
  1,
  tx_ack__field_descriptors,
  tx_ack__field_indices_by_name,
  1,  tx_ack__number_ranges,
  (ProtobufCMessageInit) tx_ack__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor ethereum_sign_tx__field_descriptors[8] =
{
  {
    "address_n",
    1,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(EthereumSignTx, n_address_n),
    offsetof(EthereumSignTx, address_n),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "nonce",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(EthereumSignTx, has_nonce),
    offsetof(EthereumSignTx, nonce),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "gas_price",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(EthereumSignTx, has_gas_price),
    offsetof(EthereumSignTx, gas_price),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "gas_limit",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(EthereumSignTx, has_gas_limit),
    offsetof(EthereumSignTx, gas_limit),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "to",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(EthereumSignTx, has_to),
    offsetof(EthereumSignTx, to),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "value",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(EthereumSignTx, has_value),
    offsetof(EthereumSignTx, value),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "data_initial_chunk",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(EthereumSignTx, has_data_initial_chunk),
    offsetof(EthereumSignTx, data_initial_chunk),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "data_length",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(EthereumSignTx, has_data_length),
    offsetof(EthereumSignTx, data_length),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned ethereum_sign_tx__field_indices_by_name[] = {
  0,   /* field[0] = address_n */
  6,   /* field[6] = data_initial_chunk */
  7,   /* field[7] = data_length */
  3,   /* field[3] = gas_limit */
  2,   /* field[2] = gas_price */
  1,   /* field[1] = nonce */
  4,   /* field[4] = to */
  5,   /* field[5] = value */
};
static const ProtobufCIntRange ethereum_sign_tx__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 8 }
};
const ProtobufCMessageDescriptor ethereum_sign_tx__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "EthereumSignTx",
  "EthereumSignTx",
  "EthereumSignTx",
  "",
  sizeof(EthereumSignTx),
  8,
  ethereum_sign_tx__field_descriptors,
  ethereum_sign_tx__field_indices_by_name,
  1,  ethereum_sign_tx__number_ranges,
  (ProtobufCMessageInit) ethereum_sign_tx__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor ethereum_tx_request__field_descriptors[4] =
{
  {
    "data_length",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(EthereumTxRequest, has_data_length),
    offsetof(EthereumTxRequest, data_length),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "signature_v",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(EthereumTxRequest, has_signature_v),
    offsetof(EthereumTxRequest, signature_v),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "signature_r",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(EthereumTxRequest, has_signature_r),
    offsetof(EthereumTxRequest, signature_r),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "signature_s",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(EthereumTxRequest, has_signature_s),
    offsetof(EthereumTxRequest, signature_s),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned ethereum_tx_request__field_indices_by_name[] = {
  0,   /* field[0] = data_length */
  2,   /* field[2] = signature_r */
  3,   /* field[3] = signature_s */
  1,   /* field[1] = signature_v */
};
static const ProtobufCIntRange ethereum_tx_request__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor ethereum_tx_request__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "EthereumTxRequest",
  "EthereumTxRequest",
  "EthereumTxRequest",
  "",
  sizeof(EthereumTxRequest),
  4,
  ethereum_tx_request__field_descriptors,
  ethereum_tx_request__field_indices_by_name,
  1,  ethereum_tx_request__number_ranges,
  (ProtobufCMessageInit) ethereum_tx_request__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor ethereum_tx_ack__field_descriptors[1] =
{
  {
    "data_chunk",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(EthereumTxAck, has_data_chunk),
    offsetof(EthereumTxAck, data_chunk),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned ethereum_tx_ack__field_indices_by_name[] = {
  0,   /* field[0] = data_chunk */
};
static const ProtobufCIntRange ethereum_tx_ack__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor ethereum_tx_ack__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "EthereumTxAck",
  "EthereumTxAck",
  "EthereumTxAck",
  "",
  sizeof(EthereumTxAck),
  1,
  ethereum_tx_ack__field_descriptors,
  ethereum_tx_ack__field_indices_by_name,
  1,  ethereum_tx_ack__number_ranges,
  (ProtobufCMessageInit) ethereum_tx_ack__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor sign_identity__field_descriptors[4] =
{
  {
    "identity",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(SignIdentity, identity),
    &identity_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "challenge_hidden",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(SignIdentity, has_challenge_hidden),
    offsetof(SignIdentity, challenge_hidden),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "challenge_visual",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(SignIdentity, challenge_visual),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "ecdsa_curve_name",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(SignIdentity, ecdsa_curve_name),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned sign_identity__field_indices_by_name[] = {
  1,   /* field[1] = challenge_hidden */
  2,   /* field[2] = challenge_visual */
  3,   /* field[3] = ecdsa_curve_name */
  0,   /* field[0] = identity */
};
static const ProtobufCIntRange sign_identity__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor sign_identity__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "SignIdentity",
  "SignIdentity",
  "SignIdentity",
  "",
  sizeof(SignIdentity),
  4,
  sign_identity__field_descriptors,
  sign_identity__field_indices_by_name,
  1,  sign_identity__number_ranges,
  (ProtobufCMessageInit) sign_identity__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor signed_identity__field_descriptors[3] =
{
  {
    "address",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(SignedIdentity, address),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "public_key",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(SignedIdentity, has_public_key),
    offsetof(SignedIdentity, public_key),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "signature",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(SignedIdentity, has_signature),
    offsetof(SignedIdentity, signature),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned signed_identity__field_indices_by_name[] = {
  0,   /* field[0] = address */
  1,   /* field[1] = public_key */
  2,   /* field[2] = signature */
};
static const ProtobufCIntRange signed_identity__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor signed_identity__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "SignedIdentity",
  "SignedIdentity",
  "SignedIdentity",
  "",
  sizeof(SignedIdentity),
  3,
  signed_identity__field_descriptors,
  signed_identity__field_indices_by_name,
  1,  signed_identity__number_ranges,
  (ProtobufCMessageInit) signed_identity__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor get_ecdhsession_key__field_descriptors[3] =
{
  {
    "identity",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GetECDHSessionKey, identity),
    &identity_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "peer_public_key",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(GetECDHSessionKey, has_peer_public_key),
    offsetof(GetECDHSessionKey, peer_public_key),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "ecdsa_curve_name",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GetECDHSessionKey, ecdsa_curve_name),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned get_ecdhsession_key__field_indices_by_name[] = {
  2,   /* field[2] = ecdsa_curve_name */
  0,   /* field[0] = identity */
  1,   /* field[1] = peer_public_key */
};
static const ProtobufCIntRange get_ecdhsession_key__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor get_ecdhsession_key__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "GetECDHSessionKey",
  "GetECDHSessionKey",
  "GetECDHSessionKey",
  "",
  sizeof(GetECDHSessionKey),
  3,
  get_ecdhsession_key__field_descriptors,
  get_ecdhsession_key__field_indices_by_name,
  1,  get_ecdhsession_key__number_ranges,
  (ProtobufCMessageInit) get_ecdhsession_key__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor ecdhsession_key__field_descriptors[1] =
{
  {
    "session_key",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(ECDHSessionKey, has_session_key),
    offsetof(ECDHSessionKey, session_key),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned ecdhsession_key__field_indices_by_name[] = {
  0,   /* field[0] = session_key */
};
static const ProtobufCIntRange ecdhsession_key__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor ecdhsession_key__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "ECDHSessionKey",
  "ECDHSessionKey",
  "ECDHSessionKey",
  "",
  sizeof(ECDHSessionKey),
  1,
  ecdhsession_key__field_descriptors,
  ecdhsession_key__field_indices_by_name,
  1,  ecdhsession_key__number_ranges,
  (ProtobufCMessageInit) ecdhsession_key__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor set_u2_fcounter__field_descriptors[1] =
{
  {
    "u2f_counter",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(SetU2FCounter, has_u2f_counter),
    offsetof(SetU2FCounter, u2f_counter),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned set_u2_fcounter__field_indices_by_name[] = {
  0,   /* field[0] = u2f_counter */
};
static const ProtobufCIntRange set_u2_fcounter__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor set_u2_fcounter__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "SetU2FCounter",
  "SetU2FCounter",
  "SetU2FCounter",
  "",
  sizeof(SetU2FCounter),
  1,
  set_u2_fcounter__field_descriptors,
  set_u2_fcounter__field_indices_by_name,
  1,  set_u2_fcounter__number_ranges,
  (ProtobufCMessageInit) set_u2_fcounter__init,
  NULL,NULL,NULL    /* reserved[123] */
};
#define firmware_erase__field_descriptors NULL
#define firmware_erase__field_indices_by_name NULL
#define firmware_erase__number_ranges NULL
const ProtobufCMessageDescriptor firmware_erase__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "FirmwareErase",
  "FirmwareErase",
  "FirmwareErase",
  "",
  sizeof(FirmwareErase),
  0,
  firmware_erase__field_descriptors,
  firmware_erase__field_indices_by_name,
  0,  firmware_erase__number_ranges,
  (ProtobufCMessageInit) firmware_erase__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor firmware_upload__field_descriptors[1] =
{
  {
    "payload",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(FirmwareUpload, payload),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned firmware_upload__field_indices_by_name[] = {
  0,   /* field[0] = payload */
};
static const ProtobufCIntRange firmware_upload__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor firmware_upload__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "FirmwareUpload",
  "FirmwareUpload",
  "FirmwareUpload",
  "",
  sizeof(FirmwareUpload),
  1,
  firmware_upload__field_descriptors,
  firmware_upload__field_indices_by_name,
  1,  firmware_upload__number_ranges,
  (ProtobufCMessageInit) firmware_upload__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor debug_link_decision__field_descriptors[1] =
{
  {
    "yes_no",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BOOL,
    0,   /* quantifier_offset */
    offsetof(DebugLinkDecision, yes_no),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned debug_link_decision__field_indices_by_name[] = {
  0,   /* field[0] = yes_no */
};
static const ProtobufCIntRange debug_link_decision__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor debug_link_decision__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "DebugLinkDecision",
  "DebugLinkDecision",
  "DebugLinkDecision",
  "",
  sizeof(DebugLinkDecision),
  1,
  debug_link_decision__field_descriptors,
  debug_link_decision__field_indices_by_name,
  1,  debug_link_decision__number_ranges,
  (ProtobufCMessageInit) debug_link_decision__init,
  NULL,NULL,NULL    /* reserved[123] */
};
#define debug_link_get_state__field_descriptors NULL
#define debug_link_get_state__field_indices_by_name NULL
#define debug_link_get_state__number_ranges NULL
const ProtobufCMessageDescriptor debug_link_get_state__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "DebugLinkGetState",
  "DebugLinkGetState",
  "DebugLinkGetState",
  "",
  sizeof(DebugLinkGetState),
  0,
  debug_link_get_state__field_descriptors,
  debug_link_get_state__field_indices_by_name,
  0,  debug_link_get_state__number_ranges,
  (ProtobufCMessageInit) debug_link_get_state__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor debug_link_state__field_descriptors[11] =
{
  {
    "layout",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(DebugLinkState, has_layout),
    offsetof(DebugLinkState, layout),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "pin",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(DebugLinkState, pin),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "matrix",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(DebugLinkState, matrix),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "mnemonic",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(DebugLinkState, mnemonic),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "node",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(DebugLinkState, node),
    &hdnode_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "passphrase_protection",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(DebugLinkState, has_passphrase_protection),
    offsetof(DebugLinkState, passphrase_protection),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "reset_word",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(DebugLinkState, reset_word),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "reset_entropy",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(DebugLinkState, has_reset_entropy),
    offsetof(DebugLinkState, reset_entropy),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "recovery_fake_word",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(DebugLinkState, recovery_fake_word),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "recovery_word_pos",
    10,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(DebugLinkState, has_recovery_word_pos),
    offsetof(DebugLinkState, recovery_word_pos),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "xmr_seckey",
    11,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(DebugLinkState, has_xmr_seckey),
    offsetof(DebugLinkState, xmr_seckey),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned debug_link_state__field_indices_by_name[] = {
  0,   /* field[0] = layout */
  2,   /* field[2] = matrix */
  3,   /* field[3] = mnemonic */
  4,   /* field[4] = node */
  5,   /* field[5] = passphrase_protection */
  1,   /* field[1] = pin */
  8,   /* field[8] = recovery_fake_word */
  9,   /* field[9] = recovery_word_pos */
  7,   /* field[7] = reset_entropy */
  6,   /* field[6] = reset_word */
  10,   /* field[10] = xmr_seckey */
};
static const ProtobufCIntRange debug_link_state__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 11 }
};
const ProtobufCMessageDescriptor debug_link_state__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "DebugLinkState",
  "DebugLinkState",
  "DebugLinkState",
  "",
  sizeof(DebugLinkState),
  11,
  debug_link_state__field_descriptors,
  debug_link_state__field_indices_by_name,
  1,  debug_link_state__number_ranges,
  (ProtobufCMessageInit) debug_link_state__init,
  NULL,NULL,NULL    /* reserved[123] */
};
#define debug_link_stop__field_descriptors NULL
#define debug_link_stop__field_indices_by_name NULL
#define debug_link_stop__number_ranges NULL
const ProtobufCMessageDescriptor debug_link_stop__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "DebugLinkStop",
  "DebugLinkStop",
  "DebugLinkStop",
  "",
  sizeof(DebugLinkStop),
  0,
  debug_link_stop__field_descriptors,
  debug_link_stop__field_indices_by_name,
  0,  debug_link_stop__number_ranges,
  (ProtobufCMessageInit) debug_link_stop__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor debug_link_log__field_descriptors[3] =
{
  {
    "level",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(DebugLinkLog, has_level),
    offsetof(DebugLinkLog, level),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "bucket",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(DebugLinkLog, bucket),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "text",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(DebugLinkLog, text),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned debug_link_log__field_indices_by_name[] = {
  1,   /* field[1] = bucket */
  0,   /* field[0] = level */
  2,   /* field[2] = text */
};
static const ProtobufCIntRange debug_link_log__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor debug_link_log__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "DebugLinkLog",
  "DebugLinkLog",
  "DebugLinkLog",
  "",
  sizeof(DebugLinkLog),
  3,
  debug_link_log__field_descriptors,
  debug_link_log__field_indices_by_name,
  1,  debug_link_log__number_ranges,
  (ProtobufCMessageInit) debug_link_log__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor debug_link_memory_read__field_descriptors[2] =
{
  {
    "address",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(DebugLinkMemoryRead, has_address),
    offsetof(DebugLinkMemoryRead, address),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "length",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(DebugLinkMemoryRead, has_length),
    offsetof(DebugLinkMemoryRead, length),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned debug_link_memory_read__field_indices_by_name[] = {
  0,   /* field[0] = address */
  1,   /* field[1] = length */
};
static const ProtobufCIntRange debug_link_memory_read__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor debug_link_memory_read__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "DebugLinkMemoryRead",
  "DebugLinkMemoryRead",
  "DebugLinkMemoryRead",
  "",
  sizeof(DebugLinkMemoryRead),
  2,
  debug_link_memory_read__field_descriptors,
  debug_link_memory_read__field_indices_by_name,
  1,  debug_link_memory_read__number_ranges,
  (ProtobufCMessageInit) debug_link_memory_read__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor debug_link_memory__field_descriptors[1] =
{
  {
    "memory",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(DebugLinkMemory, has_memory),
    offsetof(DebugLinkMemory, memory),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned debug_link_memory__field_indices_by_name[] = {
  0,   /* field[0] = memory */
};
static const ProtobufCIntRange debug_link_memory__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor debug_link_memory__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "DebugLinkMemory",
  "DebugLinkMemory",
  "DebugLinkMemory",
  "",
  sizeof(DebugLinkMemory),
  1,
  debug_link_memory__field_descriptors,
  debug_link_memory__field_indices_by_name,
  1,  debug_link_memory__number_ranges,
  (ProtobufCMessageInit) debug_link_memory__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor debug_link_memory_write__field_descriptors[3] =
{
  {
    "address",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(DebugLinkMemoryWrite, has_address),
    offsetof(DebugLinkMemoryWrite, address),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "memory",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(DebugLinkMemoryWrite, has_memory),
    offsetof(DebugLinkMemoryWrite, memory),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "flash",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(DebugLinkMemoryWrite, has_flash),
    offsetof(DebugLinkMemoryWrite, flash),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned debug_link_memory_write__field_indices_by_name[] = {
  0,   /* field[0] = address */
  2,   /* field[2] = flash */
  1,   /* field[1] = memory */
};
static const ProtobufCIntRange debug_link_memory_write__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor debug_link_memory_write__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "DebugLinkMemoryWrite",
  "DebugLinkMemoryWrite",
  "DebugLinkMemoryWrite",
  "",
  sizeof(DebugLinkMemoryWrite),
  3,
  debug_link_memory_write__field_descriptors,
  debug_link_memory_write__field_indices_by_name,
  1,  debug_link_memory_write__number_ranges,
  (ProtobufCMessageInit) debug_link_memory_write__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor debug_link_flash_erase__field_descriptors[1] =
{
  {
    "sector",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(DebugLinkFlashErase, has_sector),
    offsetof(DebugLinkFlashErase, sector),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned debug_link_flash_erase__field_indices_by_name[] = {
  0,   /* field[0] = sector */
};
static const ProtobufCIntRange debug_link_flash_erase__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor debug_link_flash_erase__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "DebugLinkFlashErase",
  "DebugLinkFlashErase",
  "DebugLinkFlashErase",
  "",
  sizeof(DebugLinkFlashErase),
  1,
  debug_link_flash_erase__field_descriptors,
  debug_link_flash_erase__field_indices_by_name,
  1,  debug_link_flash_erase__number_ranges,
  (ProtobufCMessageInit) debug_link_flash_erase__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor xmr_request_session_key__field_descriptors[1] =
{
  {
    "pubkey",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(XmrRequestSessionKey, pubkey),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned xmr_request_session_key__field_indices_by_name[] = {
  0,   /* field[0] = pubkey */
};
static const ProtobufCIntRange xmr_request_session_key__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor xmr_request_session_key__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "XmrRequestSessionKey",
  "XmrRequestSessionKey",
  "XmrRequestSessionKey",
  "",
  sizeof(XmrRequestSessionKey),
  1,
  xmr_request_session_key__field_descriptors,
  xmr_request_session_key__field_indices_by_name,
  1,  xmr_request_session_key__number_ranges,
  (ProtobufCMessageInit) xmr_request_session_key__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor xmr_request_session_key_ack__field_descriptors[1] =
{
  {
    "pubkey",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(XmrRequestSessionKeyAck, pubkey),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned xmr_request_session_key_ack__field_indices_by_name[] = {
  0,   /* field[0] = pubkey */
};
static const ProtobufCIntRange xmr_request_session_key_ack__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor xmr_request_session_key_ack__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "XmrRequestSessionKeyAck",
  "XmrRequestSessionKeyAck",
  "XmrRequestSessionKeyAck",
  "",
  sizeof(XmrRequestSessionKeyAck),
  1,
  xmr_request_session_key_ack__field_descriptors,
  xmr_request_session_key_ack__field_indices_by_name,
  1,  xmr_request_session_key_ack__number_ranges,
  (ProtobufCMessageInit) xmr_request_session_key_ack__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor xmr_request_view_key__field_descriptors[3] =
{
  {
    "account_index",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(XmrRequestViewKey, account_index),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "passphrase",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(XmrRequestViewKey, passphrase),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "display_address",
    3,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BOOL,
    0,   /* quantifier_offset */
    offsetof(XmrRequestViewKey, display_address),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned xmr_request_view_key__field_indices_by_name[] = {
  0,   /* field[0] = account_index */
  2,   /* field[2] = display_address */
  1,   /* field[1] = passphrase */
};
static const ProtobufCIntRange xmr_request_view_key__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor xmr_request_view_key__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "XmrRequestViewKey",
  "XmrRequestViewKey",
  "XmrRequestViewKey",
  "",
  sizeof(XmrRequestViewKey),
  3,
  xmr_request_view_key__field_descriptors,
  xmr_request_view_key__field_indices_by_name,
  1,  xmr_request_view_key__number_ranges,
  (ProtobufCMessageInit) xmr_request_view_key__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor xmr_request_view_key_ack__field_descriptors[3] =
{
  {
    "viewkey",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(XmrRequestViewKeyAck, viewkey),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "spendkey",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(XmrRequestViewKeyAck, spendkey),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "checksum",
    3,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(XmrRequestViewKeyAck, checksum),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned xmr_request_view_key_ack__field_indices_by_name[] = {
  2,   /* field[2] = checksum */
  1,   /* field[1] = spendkey */
  0,   /* field[0] = viewkey */
};
static const ProtobufCIntRange xmr_request_view_key_ack__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor xmr_request_view_key_ack__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "XmrRequestViewKeyAck",
  "XmrRequestViewKeyAck",
  "XmrRequestViewKeyAck",
  "",
  sizeof(XmrRequestViewKeyAck),
  3,
  xmr_request_view_key_ack__field_descriptors,
  xmr_request_view_key_ack__field_indices_by_name,
  1,  xmr_request_view_key_ack__number_ranges,
  (ProtobufCMessageInit) xmr_request_view_key_ack__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor xmr_generate_key_image__field_descriptors[4] =
{
  {
    "derivation",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateKeyImage, derivation),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "eph_pubkey",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateKeyImage, eph_pubkey),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "indices",
    3,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateKeyImage, indices),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "count",
    4,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateKeyImage, count),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned xmr_generate_key_image__field_indices_by_name[] = {
  3,   /* field[3] = count */
  0,   /* field[0] = derivation */
  1,   /* field[1] = eph_pubkey */
  2,   /* field[2] = indices */
};
static const ProtobufCIntRange xmr_generate_key_image__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor xmr_generate_key_image__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "XmrGenerateKeyImage",
  "XmrGenerateKeyImage",
  "XmrGenerateKeyImage",
  "",
  sizeof(XmrGenerateKeyImage),
  4,
  xmr_generate_key_image__field_descriptors,
  xmr_generate_key_image__field_indices_by_name,
  1,  xmr_generate_key_image__number_ranges,
  (ProtobufCMessageInit) xmr_generate_key_image__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor xmr_generate_key_image_ack__field_descriptors[2] =
{
  {
    "key_image",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateKeyImageAck, key_image),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "checksum",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateKeyImageAck, checksum),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned xmr_generate_key_image_ack__field_indices_by_name[] = {
  1,   /* field[1] = checksum */
  0,   /* field[0] = key_image */
};
static const ProtobufCIntRange xmr_generate_key_image_ack__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor xmr_generate_key_image_ack__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "XmrGenerateKeyImageAck",
  "XmrGenerateKeyImageAck",
  "XmrGenerateKeyImageAck",
  "",
  sizeof(XmrGenerateKeyImageAck),
  2,
  xmr_generate_key_image_ack__field_descriptors,
  xmr_generate_key_image_ack__field_indices_by_name,
  1,  xmr_generate_key_image_ack__number_ranges,
  (ProtobufCMessageInit) xmr_generate_key_image_ack__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor xmr_generate_signature__field_descriptors[3] =
{
  {
    "txid",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT64,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateSignature, txid),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "data",
    2,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(XmrGenerateSignature, n_data),
    offsetof(XmrGenerateSignature, data),
    &xmr_signature_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "version",
    3,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT64,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateSignature, version),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned xmr_generate_signature__field_indices_by_name[] = {
  1,   /* field[1] = data */
  0,   /* field[0] = txid */
  2,   /* field[2] = version */
};
static const ProtobufCIntRange xmr_generate_signature__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor xmr_generate_signature__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "XmrGenerateSignature",
  "XmrGenerateSignature",
  "XmrGenerateSignature",
  "",
  sizeof(XmrGenerateSignature),
  3,
  xmr_generate_signature__field_descriptors,
  xmr_generate_signature__field_indices_by_name,
  1,  xmr_generate_signature__number_ranges,
  (ProtobufCMessageInit) xmr_generate_signature__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor xmr_generate_signature_ack__field_descriptors[4] =
{
  {
    "c",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateSignatureAck, c),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "r",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateSignatureAck, r),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "tx_seckey",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(XmrGenerateSignatureAck, has_tx_seckey),
    offsetof(XmrGenerateSignatureAck, tx_seckey),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "checksum",
    4,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateSignatureAck, checksum),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned xmr_generate_signature_ack__field_indices_by_name[] = {
  0,   /* field[0] = c */
  3,   /* field[3] = checksum */
  1,   /* field[1] = r */
  2,   /* field[2] = tx_seckey */
};
static const ProtobufCIntRange xmr_generate_signature_ack__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor xmr_generate_signature_ack__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "XmrGenerateSignatureAck",
  "XmrGenerateSignatureAck",
  "XmrGenerateSignatureAck",
  "",
  sizeof(XmrGenerateSignatureAck),
  4,
  xmr_generate_signature_ack__field_descriptors,
  xmr_generate_signature_ack__field_indices_by_name,
  1,  xmr_generate_signature_ack__number_ranges,
  (ProtobufCMessageInit) xmr_generate_signature_ack__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor xmr_generate_tx_init__field_descriptors[7] =
{
  {
    "version",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT64,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateTxInit, version),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "unlock_time",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT64,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateTxInit, unlock_time),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "vin_count",
    3,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateTxInit, vin_count),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "vout_count",
    4,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateTxInit, vout_count),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "mixin",
    5,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateTxInit, mixin),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "dest_addresses",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(XmrGenerateTxInit, has_dest_addresses),
    offsetof(XmrGenerateTxInit, dest_addresses),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "tx_fee",
    7,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT64,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateTxInit, tx_fee),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned xmr_generate_tx_init__field_indices_by_name[] = {
  5,   /* field[5] = dest_addresses */
  4,   /* field[4] = mixin */
  6,   /* field[6] = tx_fee */
  1,   /* field[1] = unlock_time */
  0,   /* field[0] = version */
  2,   /* field[2] = vin_count */
  3,   /* field[3] = vout_count */
};
static const ProtobufCIntRange xmr_generate_tx_init__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 7 }
};
const ProtobufCMessageDescriptor xmr_generate_tx_init__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "XmrGenerateTxInit",
  "XmrGenerateTxInit",
  "XmrGenerateTxInit",
  "",
  sizeof(XmrGenerateTxInit),
  7,
  xmr_generate_tx_init__field_descriptors,
  xmr_generate_tx_init__field_indices_by_name,
  1,  xmr_generate_tx_init__number_ranges,
  (ProtobufCMessageInit) xmr_generate_tx_init__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor xmr_generate_tx_init_ack__field_descriptors[2] =
{
  {
    "txid",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT64,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateTxInitAck, txid),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "tx_seckey",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateTxInitAck, tx_seckey),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned xmr_generate_tx_init_ack__field_indices_by_name[] = {
  1,   /* field[1] = tx_seckey */
  0,   /* field[0] = txid */
};
static const ProtobufCIntRange xmr_generate_tx_init_ack__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor xmr_generate_tx_init_ack__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "XmrGenerateTxInitAck",
  "XmrGenerateTxInitAck",
  "XmrGenerateTxInitAck",
  "",
  sizeof(XmrGenerateTxInitAck),
  2,
  xmr_generate_tx_init_ack__field_descriptors,
  xmr_generate_tx_init_ack__field_indices_by_name,
  1,  xmr_generate_tx_init_ack__number_ranges,
  (ProtobufCMessageInit) xmr_generate_tx_init_ack__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor xmr_generate_tx_extra__field_descriptors[4] =
{
  {
    "txid",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT64,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateTxExtra, txid),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "initial",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BOOL,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateTxExtra, initial),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "payment_id",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(XmrGenerateTxExtra, has_payment_id),
    offsetof(XmrGenerateTxExtra, payment_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "payment_id_ver",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(XmrGenerateTxExtra, has_payment_id_ver),
    offsetof(XmrGenerateTxExtra, payment_id_ver),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned xmr_generate_tx_extra__field_indices_by_name[] = {
  1,   /* field[1] = initial */
  2,   /* field[2] = payment_id */
  3,   /* field[3] = payment_id_ver */
  0,   /* field[0] = txid */
};
static const ProtobufCIntRange xmr_generate_tx_extra__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor xmr_generate_tx_extra__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "XmrGenerateTxExtra",
  "XmrGenerateTxExtra",
  "XmrGenerateTxExtra",
  "",
  sizeof(XmrGenerateTxExtra),
  4,
  xmr_generate_tx_extra__field_descriptors,
  xmr_generate_tx_extra__field_indices_by_name,
  1,  xmr_generate_tx_extra__number_ranges,
  (ProtobufCMessageInit) xmr_generate_tx_extra__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor xmr_generate_tx_extra_ack__field_descriptors[2] =
{
  {
    "prefix_hash",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateTxExtraAck, prefix_hash),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "extra",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateTxExtraAck, extra),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned xmr_generate_tx_extra_ack__field_indices_by_name[] = {
  1,   /* field[1] = extra */
  0,   /* field[0] = prefix_hash */
};
static const ProtobufCIntRange xmr_generate_tx_extra_ack__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor xmr_generate_tx_extra_ack__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "XmrGenerateTxExtraAck",
  "XmrGenerateTxExtraAck",
  "XmrGenerateTxExtraAck",
  "",
  sizeof(XmrGenerateTxExtraAck),
  2,
  xmr_generate_tx_extra_ack__field_descriptors,
  xmr_generate_tx_extra_ack__field_indices_by_name,
  1,  xmr_generate_tx_extra_ack__number_ranges,
  (ProtobufCMessageInit) xmr_generate_tx_extra_ack__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor xmr_generate_tx_vin__field_descriptors[3] =
{
  {
    "txid",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT64,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateTxVin, txid),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "initial",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BOOL,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateTxVin, initial),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "ins",
    3,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(XmrGenerateTxVin, n_ins),
    offsetof(XmrGenerateTxVin, ins),
    &xmr_input_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned xmr_generate_tx_vin__field_indices_by_name[] = {
  1,   /* field[1] = initial */
  2,   /* field[2] = ins */
  0,   /* field[0] = txid */
};
static const ProtobufCIntRange xmr_generate_tx_vin__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor xmr_generate_tx_vin__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "XmrGenerateTxVin",
  "XmrGenerateTxVin",
  "XmrGenerateTxVin",
  "",
  sizeof(XmrGenerateTxVin),
  3,
  xmr_generate_tx_vin__field_descriptors,
  xmr_generate_tx_vin__field_indices_by_name,
  1,  xmr_generate_tx_vin__number_ranges,
  (ProtobufCMessageInit) xmr_generate_tx_vin__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor xmr_generate_tx_vin_ack__field_descriptors[1] =
{
  {
    "key_images",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateTxVinAck, key_images),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned xmr_generate_tx_vin_ack__field_indices_by_name[] = {
  0,   /* field[0] = key_images */
};
static const ProtobufCIntRange xmr_generate_tx_vin_ack__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor xmr_generate_tx_vin_ack__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "XmrGenerateTxVinAck",
  "XmrGenerateTxVinAck",
  "XmrGenerateTxVinAck",
  "",
  sizeof(XmrGenerateTxVinAck),
  1,
  xmr_generate_tx_vin_ack__field_descriptors,
  xmr_generate_tx_vin_ack__field_indices_by_name,
  1,  xmr_generate_tx_vin_ack__number_ranges,
  (ProtobufCMessageInit) xmr_generate_tx_vin_ack__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor xmr_generate_tx_vout__field_descriptors[3] =
{
  {
    "txid",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT64,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateTxVout, txid),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "initial",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BOOL,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateTxVout, initial),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "outs",
    3,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(XmrGenerateTxVout, n_outs),
    offsetof(XmrGenerateTxVout, outs),
    &xmr_output_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned xmr_generate_tx_vout__field_indices_by_name[] = {
  1,   /* field[1] = initial */
  2,   /* field[2] = outs */
  0,   /* field[0] = txid */
};
static const ProtobufCIntRange xmr_generate_tx_vout__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor xmr_generate_tx_vout__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "XmrGenerateTxVout",
  "XmrGenerateTxVout",
  "XmrGenerateTxVout",
  "",
  sizeof(XmrGenerateTxVout),
  3,
  xmr_generate_tx_vout__field_descriptors,
  xmr_generate_tx_vout__field_indices_by_name,
  1,  xmr_generate_tx_vout__number_ranges,
  (ProtobufCMessageInit) xmr_generate_tx_vout__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor xmr_generate_tx_vout_ack__field_descriptors[1] =
{
  {
    "pubkeys",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(XmrGenerateTxVoutAck, pubkeys),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned xmr_generate_tx_vout_ack__field_indices_by_name[] = {
  0,   /* field[0] = pubkeys */
};
static const ProtobufCIntRange xmr_generate_tx_vout_ack__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor xmr_generate_tx_vout_ack__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "XmrGenerateTxVoutAck",
  "XmrGenerateTxVoutAck",
  "XmrGenerateTxVoutAck",
  "",
  sizeof(XmrGenerateTxVoutAck),
  1,
  xmr_generate_tx_vout_ack__field_descriptors,
  xmr_generate_tx_vout_ack__field_indices_by_name,
  1,  xmr_generate_tx_vout_ack__number_ranges,
  (ProtobufCMessageInit) xmr_generate_tx_vout_ack__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCEnumValue message_type__enum_values_by_number[82] =
{
  { "MessageType_Initialize", "MESSAGE_TYPE__MessageType_Initialize", 0 },
  { "MessageType_Ping", "MESSAGE_TYPE__MessageType_Ping", 1 },
  { "MessageType_Success", "MESSAGE_TYPE__MessageType_Success", 2 },
  { "MessageType_Failure", "MESSAGE_TYPE__MessageType_Failure", 3 },
  { "MessageType_ChangePin", "MESSAGE_TYPE__MessageType_ChangePin", 4 },
  { "MessageType_WipeDevice", "MESSAGE_TYPE__MessageType_WipeDevice", 5 },
  { "MessageType_FirmwareErase", "MESSAGE_TYPE__MessageType_FirmwareErase", 6 },
  { "MessageType_FirmwareUpload", "MESSAGE_TYPE__MessageType_FirmwareUpload", 7 },
  { "MessageType_GetEntropy", "MESSAGE_TYPE__MessageType_GetEntropy", 9 },
  { "MessageType_Entropy", "MESSAGE_TYPE__MessageType_Entropy", 10 },
  { "MessageType_GetPublicKey", "MESSAGE_TYPE__MessageType_GetPublicKey", 11 },
  { "MessageType_PublicKey", "MESSAGE_TYPE__MessageType_PublicKey", 12 },
  { "MessageType_LoadDevice", "MESSAGE_TYPE__MessageType_LoadDevice", 13 },
  { "MessageType_ResetDevice", "MESSAGE_TYPE__MessageType_ResetDevice", 14 },
  { "MessageType_SignTx", "MESSAGE_TYPE__MessageType_SignTx", 15 },
  { "MessageType_SimpleSignTx", "MESSAGE_TYPE__MessageType_SimpleSignTx", 16 },
  { "MessageType_Features", "MESSAGE_TYPE__MessageType_Features", 17 },
  { "MessageType_PinMatrixRequest", "MESSAGE_TYPE__MessageType_PinMatrixRequest", 18 },
  { "MessageType_PinMatrixAck", "MESSAGE_TYPE__MessageType_PinMatrixAck", 19 },
  { "MessageType_Cancel", "MESSAGE_TYPE__MessageType_Cancel", 20 },
  { "MessageType_TxRequest", "MESSAGE_TYPE__MessageType_TxRequest", 21 },
  { "MessageType_TxAck", "MESSAGE_TYPE__MessageType_TxAck", 22 },
  { "MessageType_CipherKeyValue", "MESSAGE_TYPE__MessageType_CipherKeyValue", 23 },
  { "MessageType_ClearSession", "MESSAGE_TYPE__MessageType_ClearSession", 24 },
  { "MessageType_ApplySettings", "MESSAGE_TYPE__MessageType_ApplySettings", 25 },
  { "MessageType_ButtonRequest", "MESSAGE_TYPE__MessageType_ButtonRequest", 26 },
  { "MessageType_ButtonAck", "MESSAGE_TYPE__MessageType_ButtonAck", 27 },
  { "MessageType_GetAddress", "MESSAGE_TYPE__MessageType_GetAddress", 29 },
  { "MessageType_Address", "MESSAGE_TYPE__MessageType_Address", 30 },
  { "MessageType_EntropyRequest", "MESSAGE_TYPE__MessageType_EntropyRequest", 35 },
  { "MessageType_EntropyAck", "MESSAGE_TYPE__MessageType_EntropyAck", 36 },
  { "MessageType_SignMessage", "MESSAGE_TYPE__MessageType_SignMessage", 38 },
  { "MessageType_VerifyMessage", "MESSAGE_TYPE__MessageType_VerifyMessage", 39 },
  { "MessageType_MessageSignature", "MESSAGE_TYPE__MessageType_MessageSignature", 40 },
  { "MessageType_PassphraseRequest", "MESSAGE_TYPE__MessageType_PassphraseRequest", 41 },
  { "MessageType_PassphraseAck", "MESSAGE_TYPE__MessageType_PassphraseAck", 42 },
  { "MessageType_EstimateTxSize", "MESSAGE_TYPE__MessageType_EstimateTxSize", 43 },
  { "MessageType_TxSize", "MESSAGE_TYPE__MessageType_TxSize", 44 },
  { "MessageType_RecoveryDevice", "MESSAGE_TYPE__MessageType_RecoveryDevice", 45 },
  { "MessageType_WordRequest", "MESSAGE_TYPE__MessageType_WordRequest", 46 },
  { "MessageType_WordAck", "MESSAGE_TYPE__MessageType_WordAck", 47 },
  { "MessageType_CipheredKeyValue", "MESSAGE_TYPE__MessageType_CipheredKeyValue", 48 },
  { "MessageType_EncryptMessage", "MESSAGE_TYPE__MessageType_EncryptMessage", 49 },
  { "MessageType_EncryptedMessage", "MESSAGE_TYPE__MessageType_EncryptedMessage", 50 },
  { "MessageType_DecryptMessage", "MESSAGE_TYPE__MessageType_DecryptMessage", 51 },
  { "MessageType_DecryptedMessage", "MESSAGE_TYPE__MessageType_DecryptedMessage", 52 },
  { "MessageType_SignIdentity", "MESSAGE_TYPE__MessageType_SignIdentity", 53 },
  { "MessageType_SignedIdentity", "MESSAGE_TYPE__MessageType_SignedIdentity", 54 },
  { "MessageType_GetFeatures", "MESSAGE_TYPE__MessageType_GetFeatures", 55 },
  { "MessageType_EthereumGetAddress", "MESSAGE_TYPE__MessageType_EthereumGetAddress", 56 },
  { "MessageType_EthereumAddress", "MESSAGE_TYPE__MessageType_EthereumAddress", 57 },
  { "MessageType_EthereumSignTx", "MESSAGE_TYPE__MessageType_EthereumSignTx", 58 },
  { "MessageType_EthereumTxRequest", "MESSAGE_TYPE__MessageType_EthereumTxRequest", 59 },
  { "MessageType_EthereumTxAck", "MESSAGE_TYPE__MessageType_EthereumTxAck", 60 },
  { "MessageType_GetECDHSessionKey", "MESSAGE_TYPE__MessageType_GetECDHSessionKey", 61 },
  { "MessageType_ECDHSessionKey", "MESSAGE_TYPE__MessageType_ECDHSessionKey", 62 },
  { "MessageType_SetU2FCounter", "MESSAGE_TYPE__MessageType_SetU2FCounter", 63 },
  { "MessageType_DebugLinkDecision", "MESSAGE_TYPE__MessageType_DebugLinkDecision", 100 },
  { "MessageType_DebugLinkGetState", "MESSAGE_TYPE__MessageType_DebugLinkGetState", 101 },
  { "MessageType_DebugLinkState", "MESSAGE_TYPE__MessageType_DebugLinkState", 102 },
  { "MessageType_DebugLinkStop", "MESSAGE_TYPE__MessageType_DebugLinkStop", 103 },
  { "MessageType_DebugLinkLog", "MESSAGE_TYPE__MessageType_DebugLinkLog", 104 },
  { "MessageType_DebugLinkMemoryRead", "MESSAGE_TYPE__MessageType_DebugLinkMemoryRead", 110 },
  { "MessageType_DebugLinkMemory", "MESSAGE_TYPE__MessageType_DebugLinkMemory", 111 },
  { "MessageType_DebugLinkMemoryWrite", "MESSAGE_TYPE__MessageType_DebugLinkMemoryWrite", 112 },
  { "MessageType_DebugLinkFlashErase", "MESSAGE_TYPE__MessageType_DebugLinkFlashErase", 113 },
  { "MessageType_XmrRequestSessionKey", "MESSAGE_TYPE__MessageType_XmrRequestSessionKey", 204 },
  { "MessageType_XmrRequestSessionKeyAck", "MESSAGE_TYPE__MessageType_XmrRequestSessionKeyAck", 205 },
  { "MessageType_XmrRequestViewKey", "MESSAGE_TYPE__MessageType_XmrRequestViewKey", 206 },
  { "MessageType_XmrRequestViewKeyAck", "MESSAGE_TYPE__MessageType_XmrRequestViewKeyAck", 207 },
  { "MessageType_XmrGenerateKeyImage", "MESSAGE_TYPE__MessageType_XmrGenerateKeyImage", 208 },
  { "MessageType_XmrGenerateKeyImageAck", "MESSAGE_TYPE__MessageType_XmrGenerateKeyImageAck", 209 },
  { "MessageType_XmrGenerateSignature", "MESSAGE_TYPE__MessageType_XmrGenerateSignature", 210 },
  { "MessageType_XmrGenerateSignatureAck", "MESSAGE_TYPE__MessageType_XmrGenerateSignatureAck", 211 },
  { "MessageType_XmrGenerateTxInit", "MESSAGE_TYPE__MessageType_XmrGenerateTxInit", 212 },
  { "MessageType_XmrGenerateTxInitAck", "MESSAGE_TYPE__MessageType_XmrGenerateTxInitAck", 213 },
  { "MessageType_XmrGenerateTxExtra", "MESSAGE_TYPE__MessageType_XmrGenerateTxExtra", 214 },
  { "MessageType_XmrGenerateTxExtraAck", "MESSAGE_TYPE__MessageType_XmrGenerateTxExtraAck", 215 },
  { "MessageType_XmrGenerateTxVin", "MESSAGE_TYPE__MessageType_XmrGenerateTxVin", 216 },
  { "MessageType_XmrGenerateTxVinAck", "MESSAGE_TYPE__MessageType_XmrGenerateTxVinAck", 217 },
  { "MessageType_XmrGenerateTxVout", "MESSAGE_TYPE__MessageType_XmrGenerateTxVout", 218 },
  { "MessageType_XmrGenerateTxVoutAck", "MESSAGE_TYPE__MessageType_XmrGenerateTxVoutAck", 219 },
};
static const ProtobufCIntRange message_type__value_ranges[] = {
{0, 0},{9, 8},{29, 27},{35, 29},{38, 31},{100, 57},{110, 62},{204, 66},{0, 82}
};
static const ProtobufCEnumValueIndex message_type__enum_values_by_name[82] =
{
  { "MessageType_Address", 28 },
  { "MessageType_ApplySettings", 24 },
  { "MessageType_ButtonAck", 26 },
  { "MessageType_ButtonRequest", 25 },
  { "MessageType_Cancel", 19 },
  { "MessageType_ChangePin", 4 },
  { "MessageType_CipherKeyValue", 22 },
  { "MessageType_CipheredKeyValue", 41 },
  { "MessageType_ClearSession", 23 },
  { "MessageType_DebugLinkDecision", 57 },
  { "MessageType_DebugLinkFlashErase", 65 },
  { "MessageType_DebugLinkGetState", 58 },
  { "MessageType_DebugLinkLog", 61 },
  { "MessageType_DebugLinkMemory", 63 },
  { "MessageType_DebugLinkMemoryRead", 62 },
  { "MessageType_DebugLinkMemoryWrite", 64 },
  { "MessageType_DebugLinkState", 59 },
  { "MessageType_DebugLinkStop", 60 },
  { "MessageType_DecryptMessage", 44 },
  { "MessageType_DecryptedMessage", 45 },
  { "MessageType_ECDHSessionKey", 55 },
  { "MessageType_EncryptMessage", 42 },
  { "MessageType_EncryptedMessage", 43 },
  { "MessageType_Entropy", 9 },
  { "MessageType_EntropyAck", 30 },
  { "MessageType_EntropyRequest", 29 },
  { "MessageType_EstimateTxSize", 36 },
  { "MessageType_EthereumAddress", 50 },
  { "MessageType_EthereumGetAddress", 49 },
  { "MessageType_EthereumSignTx", 51 },
  { "MessageType_EthereumTxAck", 53 },
  { "MessageType_EthereumTxRequest", 52 },
  { "MessageType_Failure", 3 },
  { "MessageType_Features", 16 },
  { "MessageType_FirmwareErase", 6 },
  { "MessageType_FirmwareUpload", 7 },
  { "MessageType_GetAddress", 27 },
  { "MessageType_GetECDHSessionKey", 54 },
  { "MessageType_GetEntropy", 8 },
  { "MessageType_GetFeatures", 48 },
  { "MessageType_GetPublicKey", 10 },
  { "MessageType_Initialize", 0 },
  { "MessageType_LoadDevice", 12 },
  { "MessageType_MessageSignature", 33 },
  { "MessageType_PassphraseAck", 35 },
  { "MessageType_PassphraseRequest", 34 },
  { "MessageType_PinMatrixAck", 18 },
  { "MessageType_PinMatrixRequest", 17 },
  { "MessageType_Ping", 1 },
  { "MessageType_PublicKey", 11 },
  { "MessageType_RecoveryDevice", 38 },
  { "MessageType_ResetDevice", 13 },
  { "MessageType_SetU2FCounter", 56 },
  { "MessageType_SignIdentity", 46 },
  { "MessageType_SignMessage", 31 },
  { "MessageType_SignTx", 14 },
  { "MessageType_SignedIdentity", 47 },
  { "MessageType_SimpleSignTx", 15 },
  { "MessageType_Success", 2 },
  { "MessageType_TxAck", 21 },
  { "MessageType_TxRequest", 20 },
  { "MessageType_TxSize", 37 },
  { "MessageType_VerifyMessage", 32 },
  { "MessageType_WipeDevice", 5 },
  { "MessageType_WordAck", 40 },
  { "MessageType_WordRequest", 39 },
  { "MessageType_XmrGenerateKeyImage", 70 },
  { "MessageType_XmrGenerateKeyImageAck", 71 },
  { "MessageType_XmrGenerateSignature", 72 },
  { "MessageType_XmrGenerateSignatureAck", 73 },
  { "MessageType_XmrGenerateTxExtra", 76 },
  { "MessageType_XmrGenerateTxExtraAck", 77 },
  { "MessageType_XmrGenerateTxInit", 74 },
  { "MessageType_XmrGenerateTxInitAck", 75 },
  { "MessageType_XmrGenerateTxVin", 78 },
  { "MessageType_XmrGenerateTxVinAck", 79 },
  { "MessageType_XmrGenerateTxVout", 80 },
  { "MessageType_XmrGenerateTxVoutAck", 81 },
  { "MessageType_XmrRequestSessionKey", 66 },
  { "MessageType_XmrRequestSessionKeyAck", 67 },
  { "MessageType_XmrRequestViewKey", 68 },
  { "MessageType_XmrRequestViewKeyAck", 69 },
};
const ProtobufCEnumDescriptor message_type__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "MessageType",
  "MessageType",
  "MessageType",
  "",
  82,
  message_type__enum_values_by_number,
  82,
  message_type__enum_values_by_name,
  8,
  message_type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
