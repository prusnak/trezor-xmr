/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: messages.proto */

#ifndef PROTOBUF_C_messages_2eproto__INCLUDED
#define PROTOBUF_C_messages_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1000000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1001001 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif

#include "types.pb-c.h"

typedef struct _Initialize Initialize;
typedef struct _GetFeatures GetFeatures;
typedef struct _Features Features;
typedef struct _ClearSession ClearSession;
typedef struct _ApplySettings ApplySettings;
typedef struct _ChangePin ChangePin;
typedef struct _Ping Ping;
typedef struct _Success Success;
typedef struct _Failure Failure;
typedef struct _ButtonRequest ButtonRequest;
typedef struct _ButtonAck ButtonAck;
typedef struct _PinMatrixRequest PinMatrixRequest;
typedef struct _PinMatrixAck PinMatrixAck;
typedef struct _Cancel Cancel;
typedef struct _PassphraseRequest PassphraseRequest;
typedef struct _PassphraseAck PassphraseAck;
typedef struct _GetEntropy GetEntropy;
typedef struct _Entropy Entropy;
typedef struct _GetPublicKey GetPublicKey;
typedef struct _PublicKey PublicKey;
typedef struct _GetAddress GetAddress;
typedef struct _EthereumGetAddress EthereumGetAddress;
typedef struct _Address Address;
typedef struct _EthereumAddress EthereumAddress;
typedef struct _WipeDevice WipeDevice;
typedef struct _LoadDevice LoadDevice;
typedef struct _ResetDevice ResetDevice;
typedef struct _EntropyRequest EntropyRequest;
typedef struct _EntropyAck EntropyAck;
typedef struct _RecoveryDevice RecoveryDevice;
typedef struct _WordRequest WordRequest;
typedef struct _WordAck WordAck;
typedef struct _SignMessage SignMessage;
typedef struct _VerifyMessage VerifyMessage;
typedef struct _MessageSignature MessageSignature;
typedef struct _EncryptMessage EncryptMessage;
typedef struct _EncryptedMessage EncryptedMessage;
typedef struct _DecryptMessage DecryptMessage;
typedef struct _DecryptedMessage DecryptedMessage;
typedef struct _CipherKeyValue CipherKeyValue;
typedef struct _CipheredKeyValue CipheredKeyValue;
typedef struct _EstimateTxSize EstimateTxSize;
typedef struct _TxSize TxSize;
typedef struct _SignTx SignTx;
typedef struct _SimpleSignTx SimpleSignTx;
typedef struct _TxRequest TxRequest;
typedef struct _TxAck TxAck;
typedef struct _EthereumSignTx EthereumSignTx;
typedef struct _EthereumTxRequest EthereumTxRequest;
typedef struct _EthereumTxAck EthereumTxAck;
typedef struct _SignIdentity SignIdentity;
typedef struct _SignedIdentity SignedIdentity;
typedef struct _GetECDHSessionKey GetECDHSessionKey;
typedef struct _ECDHSessionKey ECDHSessionKey;
typedef struct _SetU2FCounter SetU2FCounter;
typedef struct _FirmwareErase FirmwareErase;
typedef struct _FirmwareUpload FirmwareUpload;
typedef struct _DebugLinkDecision DebugLinkDecision;
typedef struct _DebugLinkGetState DebugLinkGetState;
typedef struct _DebugLinkState DebugLinkState;
typedef struct _DebugLinkStop DebugLinkStop;
typedef struct _DebugLinkLog DebugLinkLog;
typedef struct _DebugLinkMemoryRead DebugLinkMemoryRead;
typedef struct _DebugLinkMemory DebugLinkMemory;
typedef struct _DebugLinkMemoryWrite DebugLinkMemoryWrite;
typedef struct _DebugLinkFlashErase DebugLinkFlashErase;
typedef struct _XmrRequestSessionKey XmrRequestSessionKey;
typedef struct _XmrRequestSessionKeyAck XmrRequestSessionKeyAck;
typedef struct _XmrRequestViewKey XmrRequestViewKey;
typedef struct _XmrRequestViewKeyAck XmrRequestViewKeyAck;
typedef struct _XmrGenerateKeyImage XmrGenerateKeyImage;
typedef struct _XmrGenerateKeyImageAck XmrGenerateKeyImageAck;
typedef struct _XmrGenerateSignature XmrGenerateSignature;
typedef struct _XmrGenerateSignatureAck XmrGenerateSignatureAck;
typedef struct _XmrGenerateTxInit XmrGenerateTxInit;
typedef struct _XmrGenerateTxInitAck XmrGenerateTxInitAck;
typedef struct _XmrGenerateTxExtra XmrGenerateTxExtra;
typedef struct _XmrGenerateTxExtraAck XmrGenerateTxExtraAck;
typedef struct _XmrGenerateTxVin XmrGenerateTxVin;
typedef struct _XmrGenerateTxVinAck XmrGenerateTxVinAck;
typedef struct _XmrGenerateTxVout XmrGenerateTxVout;
typedef struct _XmrGenerateTxVoutAck XmrGenerateTxVoutAck;


/* --- enums --- */

/*
 **
 * Mapping between Trezor wire identifier (uint) and a protobuf message
 */
typedef enum _MessageType {
  MESSAGE_TYPE__MessageType_Initialize = 0,
  MESSAGE_TYPE__MessageType_Ping = 1,
  MESSAGE_TYPE__MessageType_Success = 2,
  MESSAGE_TYPE__MessageType_Failure = 3,
  MESSAGE_TYPE__MessageType_ChangePin = 4,
  MESSAGE_TYPE__MessageType_WipeDevice = 5,
  MESSAGE_TYPE__MessageType_FirmwareErase = 6,
  MESSAGE_TYPE__MessageType_FirmwareUpload = 7,
  MESSAGE_TYPE__MessageType_GetEntropy = 9,
  MESSAGE_TYPE__MessageType_Entropy = 10,
  MESSAGE_TYPE__MessageType_GetPublicKey = 11,
  MESSAGE_TYPE__MessageType_PublicKey = 12,
  MESSAGE_TYPE__MessageType_LoadDevice = 13,
  MESSAGE_TYPE__MessageType_ResetDevice = 14,
  MESSAGE_TYPE__MessageType_SignTx = 15,
  MESSAGE_TYPE__MessageType_SimpleSignTx = 16,
  MESSAGE_TYPE__MessageType_Features = 17,
  MESSAGE_TYPE__MessageType_PinMatrixRequest = 18,
  MESSAGE_TYPE__MessageType_PinMatrixAck = 19,
  MESSAGE_TYPE__MessageType_Cancel = 20,
  MESSAGE_TYPE__MessageType_TxRequest = 21,
  MESSAGE_TYPE__MessageType_TxAck = 22,
  MESSAGE_TYPE__MessageType_CipherKeyValue = 23,
  MESSAGE_TYPE__MessageType_ClearSession = 24,
  MESSAGE_TYPE__MessageType_ApplySettings = 25,
  MESSAGE_TYPE__MessageType_ButtonRequest = 26,
  MESSAGE_TYPE__MessageType_ButtonAck = 27,
  MESSAGE_TYPE__MessageType_GetAddress = 29,
  MESSAGE_TYPE__MessageType_Address = 30,
  MESSAGE_TYPE__MessageType_EntropyRequest = 35,
  MESSAGE_TYPE__MessageType_EntropyAck = 36,
  MESSAGE_TYPE__MessageType_SignMessage = 38,
  MESSAGE_TYPE__MessageType_VerifyMessage = 39,
  MESSAGE_TYPE__MessageType_MessageSignature = 40,
  MESSAGE_TYPE__MessageType_PassphraseRequest = 41,
  MESSAGE_TYPE__MessageType_PassphraseAck = 42,
  MESSAGE_TYPE__MessageType_EstimateTxSize = 43,
  MESSAGE_TYPE__MessageType_TxSize = 44,
  MESSAGE_TYPE__MessageType_RecoveryDevice = 45,
  MESSAGE_TYPE__MessageType_WordRequest = 46,
  MESSAGE_TYPE__MessageType_WordAck = 47,
  MESSAGE_TYPE__MessageType_CipheredKeyValue = 48,
  MESSAGE_TYPE__MessageType_EncryptMessage = 49,
  MESSAGE_TYPE__MessageType_EncryptedMessage = 50,
  MESSAGE_TYPE__MessageType_DecryptMessage = 51,
  MESSAGE_TYPE__MessageType_DecryptedMessage = 52,
  MESSAGE_TYPE__MessageType_SignIdentity = 53,
  MESSAGE_TYPE__MessageType_SignedIdentity = 54,
  MESSAGE_TYPE__MessageType_GetFeatures = 55,
  MESSAGE_TYPE__MessageType_EthereumGetAddress = 56,
  MESSAGE_TYPE__MessageType_EthereumAddress = 57,
  MESSAGE_TYPE__MessageType_EthereumSignTx = 58,
  MESSAGE_TYPE__MessageType_EthereumTxRequest = 59,
  MESSAGE_TYPE__MessageType_EthereumTxAck = 60,
  MESSAGE_TYPE__MessageType_GetECDHSessionKey = 61,
  MESSAGE_TYPE__MessageType_ECDHSessionKey = 62,
  MESSAGE_TYPE__MessageType_SetU2FCounter = 63,
  MESSAGE_TYPE__MessageType_DebugLinkDecision = 100,
  MESSAGE_TYPE__MessageType_DebugLinkGetState = 101,
  MESSAGE_TYPE__MessageType_DebugLinkState = 102,
  MESSAGE_TYPE__MessageType_DebugLinkStop = 103,
  MESSAGE_TYPE__MessageType_DebugLinkLog = 104,
  MESSAGE_TYPE__MessageType_DebugLinkMemoryRead = 110,
  MESSAGE_TYPE__MessageType_DebugLinkMemory = 111,
  MESSAGE_TYPE__MessageType_DebugLinkMemoryWrite = 112,
  MESSAGE_TYPE__MessageType_DebugLinkFlashErase = 113,
  MESSAGE_TYPE__MessageType_XmrRequestSessionKey = 204,
  MESSAGE_TYPE__MessageType_XmrRequestSessionKeyAck = 205,
  MESSAGE_TYPE__MessageType_XmrRequestViewKey = 206,
  MESSAGE_TYPE__MessageType_XmrRequestViewKeyAck = 207,
  MESSAGE_TYPE__MessageType_XmrGenerateKeyImage = 208,
  MESSAGE_TYPE__MessageType_XmrGenerateKeyImageAck = 209,
  MESSAGE_TYPE__MessageType_XmrGenerateSignature = 210,
  MESSAGE_TYPE__MessageType_XmrGenerateSignatureAck = 211,
  MESSAGE_TYPE__MessageType_XmrGenerateTxInit = 212,
  MESSAGE_TYPE__MessageType_XmrGenerateTxInitAck = 213,
  MESSAGE_TYPE__MessageType_XmrGenerateTxExtra = 214,
  MESSAGE_TYPE__MessageType_XmrGenerateTxExtraAck = 215,
  MESSAGE_TYPE__MessageType_XmrGenerateTxVin = 216,
  MESSAGE_TYPE__MessageType_XmrGenerateTxVinAck = 217,
  MESSAGE_TYPE__MessageType_XmrGenerateTxVout = 218,
  MESSAGE_TYPE__MessageType_XmrGenerateTxVoutAck = 219
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(MESSAGE_TYPE)
} MessageType;

/* --- messages --- */

/*
 **
 * Request: Reset device to default state and ask for device details
 * @next Features
 */
struct  _Initialize
{
  ProtobufCMessage base;
};
#define INITIALIZE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&initialize__descriptor) \
     }


/*
 **
 * Request: Ask for device details (no device reset)
 * @next Features
 */
struct  _GetFeatures
{
  ProtobufCMessage base;
};
#define GET_FEATURES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&get_features__descriptor) \
     }


/*
 **
 * Response: Reports various information about the device
 * @prev Initialize
 * @prev GetFeatures
 */
struct  _Features
{
  ProtobufCMessage base;
  /*
   * name of the manufacturer, e.g. "bitcointrezor.com"
   */
  char *vendor;
  /*
   * major version of the device, e.g. 1
   */
  protobuf_c_boolean has_major_version;
  uint32_t major_version;
  /*
   * minor version of the device, e.g. 0
   */
  protobuf_c_boolean has_minor_version;
  uint32_t minor_version;
  /*
   * patch version of the device, e.g. 0
   */
  protobuf_c_boolean has_patch_version;
  uint32_t patch_version;
  /*
   * is device in bootloader mode?
   */
  protobuf_c_boolean has_bootloader_mode;
  protobuf_c_boolean bootloader_mode;
  /*
   * device's unique identifier
   */
  char *device_id;
  /*
   * is device protected by PIN?
   */
  protobuf_c_boolean has_pin_protection;
  protobuf_c_boolean pin_protection;
  /*
   * is node/mnemonic encrypted using passphrase?
   */
  protobuf_c_boolean has_passphrase_protection;
  protobuf_c_boolean passphrase_protection;
  /*
   * device language
   */
  char *language;
  /*
   * device description label
   */
  char *label;
  /*
   * supported coins
   */
  size_t n_coins;
  CoinType **coins;
  /*
   * does device contain seed?
   */
  protobuf_c_boolean has_initialized;
  protobuf_c_boolean initialized;
  /*
   * SCM revision of firmware
   */
  protobuf_c_boolean has_revision;
  ProtobufCBinaryData revision;
  /*
   * hash of the bootloader
   */
  protobuf_c_boolean has_bootloader_hash;
  ProtobufCBinaryData bootloader_hash;
  /*
   * was storage imported from an external source?
   */
  protobuf_c_boolean has_imported;
  protobuf_c_boolean imported;
  /*
   * is PIN already cached in session?
   */
  protobuf_c_boolean has_pin_cached;
  protobuf_c_boolean pin_cached;
  /*
   * is passphrase already cached in session?
   */
  protobuf_c_boolean has_passphrase_cached;
  protobuf_c_boolean passphrase_cached;
};
#define FEATURES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&features__descriptor) \
    , NULL, 0,0, 0,0, 0,0, 0,0, NULL, 0,0, 0,0, NULL, NULL, 0,NULL, 0,0, 0,{0,NULL}, 0,{0,NULL}, 0,0, 0,0, 0,0 }


/*
 **
 * Request: clear session (removes cached PIN, passphrase, etc).
 * @next Success
 */
struct  _ClearSession
{
  ProtobufCMessage base;
};
#define CLEAR_SESSION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&clear_session__descriptor) \
     }


/*
 **
 * Request: change language and/or label of the device
 * @next Success
 * @next Failure
 * @next ButtonRequest
 * @next PinMatrixRequest
 */
struct  _ApplySettings
{
  ProtobufCMessage base;
  char *language;
  char *label;
  protobuf_c_boolean has_use_passphrase;
  protobuf_c_boolean use_passphrase;
  protobuf_c_boolean has_homescreen;
  ProtobufCBinaryData homescreen;
};
#define APPLY_SETTINGS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&apply_settings__descriptor) \
    , NULL, NULL, 0,0, 0,{0,NULL} }


/*
 **
 * Request: Starts workflow for setting/changing/removing the PIN
 * @next ButtonRequest
 * @next PinMatrixRequest
 */
struct  _ChangePin
{
  ProtobufCMessage base;
  /*
   * is PIN removal requested?
   */
  protobuf_c_boolean has_remove;
  protobuf_c_boolean remove;
};
#define CHANGE_PIN__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&change_pin__descriptor) \
    , 0,0 }


/*
 **
 * Request: Test if the device is alive, device sends back the message in Success response
 * @next Success
 */
struct  _Ping
{
  ProtobufCMessage base;
  /*
   * message to send back in Success message
   */
  char *message;
  /*
   * ask for button press
   */
  protobuf_c_boolean has_button_protection;
  protobuf_c_boolean button_protection;
  /*
   * ask for PIN if set in device
   */
  protobuf_c_boolean has_pin_protection;
  protobuf_c_boolean pin_protection;
  /*
   * ask for passphrase if set in device
   */
  protobuf_c_boolean has_passphrase_protection;
  protobuf_c_boolean passphrase_protection;
};
#define PING__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&ping__descriptor) \
    , NULL, 0,0, 0,0, 0,0 }


/*
 **
 * Response: Success of the previous request
 */
struct  _Success
{
  ProtobufCMessage base;
  /*
   * human readable description of action or request-specific payload
   */
  char *message;
};
#define SUCCESS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&success__descriptor) \
    , NULL }


/*
 **
 * Response: Failure of the previous request
 */
struct  _Failure
{
  ProtobufCMessage base;
  /*
   * computer-readable definition of the error state
   */
  protobuf_c_boolean has_code;
  FailureType code;
  /*
   * human-readable message of the error state
   */
  char *message;
};
#define FAILURE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&failure__descriptor) \
    , 0,0, NULL }


/*
 **
 * Response: Device is waiting for HW button press.
 * @next ButtonAck
 * @next Cancel
 */
struct  _ButtonRequest
{
  ProtobufCMessage base;
  protobuf_c_boolean has_code;
  ButtonRequestType code;
  char *data;
};
#define BUTTON_REQUEST__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&button_request__descriptor) \
    , 0,0, NULL }


/*
 **
 * Request: Computer agrees to wait for HW button press
 * @prev ButtonRequest
 */
struct  _ButtonAck
{
  ProtobufCMessage base;
};
#define BUTTON_ACK__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&button_ack__descriptor) \
     }


/*
 **
 * Response: Device is asking computer to show PIN matrix and awaits PIN encoded using this matrix scheme
 * @next PinMatrixAck
 * @next Cancel
 */
struct  _PinMatrixRequest
{
  ProtobufCMessage base;
  protobuf_c_boolean has_type;
  PinMatrixRequestType type;
};
#define PIN_MATRIX_REQUEST__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&pin_matrix_request__descriptor) \
    , 0,0 }


/*
 **
 * Request: Computer responds with encoded PIN
 * @prev PinMatrixRequest
 */
struct  _PinMatrixAck
{
  ProtobufCMessage base;
  /*
   * matrix encoded PIN entered by user
   */
  char *pin;
};
#define PIN_MATRIX_ACK__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&pin_matrix_ack__descriptor) \
    , NULL }


/*
 **
 * Request: Abort last operation that required user interaction
 * @prev ButtonRequest
 * @prev PinMatrixRequest
 * @prev PassphraseRequest
 */
struct  _Cancel
{
  ProtobufCMessage base;
};
#define CANCEL__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cancel__descriptor) \
     }


/*
 **
 * Response: Device awaits encryption passphrase
 * @next PassphraseAck
 * @next Cancel
 */
struct  _PassphraseRequest
{
  ProtobufCMessage base;
};
#define PASSPHRASE_REQUEST__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&passphrase_request__descriptor) \
     }


/*
 **
 * Request: Send passphrase back
 * @prev PassphraseRequest
 */
struct  _PassphraseAck
{
  ProtobufCMessage base;
  char *passphrase;
};
#define PASSPHRASE_ACK__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&passphrase_ack__descriptor) \
    , NULL }


/*
 **
 * Request: Request a sample of random data generated by hardware RNG. May be used for testing.
 * @next ButtonRequest
 * @next Entropy
 * @next Failure
 */
struct  _GetEntropy
{
  ProtobufCMessage base;
  /*
   * size of requested entropy
   */
  uint32_t size;
};
#define GET_ENTROPY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&get_entropy__descriptor) \
    , 0 }


/*
 **
 * Response: Reply with random data generated by internal RNG
 * @prev GetEntropy
 */
struct  _Entropy
{
  ProtobufCMessage base;
  /*
   * stream of random generated bytes
   */
  ProtobufCBinaryData entropy;
};
#define ENTROPY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&entropy__descriptor) \
    , {0,NULL} }


/*
 **
 * Request: Ask device for public key corresponding to address_n path
 * @next PassphraseRequest
 * @next PublicKey
 * @next Failure
 */
struct  _GetPublicKey
{
  ProtobufCMessage base;
  /*
   * BIP-32 path to derive the key from master node
   */
  size_t n_address_n;
  uint32_t *address_n;
  /*
   * ECDSA curve name to use
   */
  char *ecdsa_curve_name;
  /*
   * optionally show on display before sending the result
   */
  protobuf_c_boolean has_show_display;
  protobuf_c_boolean show_display;
};
#define GET_PUBLIC_KEY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&get_public_key__descriptor) \
    , 0,NULL, NULL, 0,0 }


/*
 **
 * Response: Contains public key derived from device private seed
 * @prev GetPublicKey
 */
struct  _PublicKey
{
  ProtobufCMessage base;
  /*
   * BIP32 public node
   */
  HDNodeType *node;
  /*
   * serialized form of public node
   */
  char *xpub;
};
#define PUBLIC_KEY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&public_key__descriptor) \
    , NULL, NULL }


/*
 **
 * Request: Ask device for address corresponding to address_n path
 * @next PassphraseRequest
 * @next Address
 * @next Failure
 */
struct  _GetAddress
{
  ProtobufCMessage base;
  /*
   * BIP-32 path to derive the key from master node
   */
  size_t n_address_n;
  uint32_t *address_n;
  char *coin_name;
  /*
   * optionally show on display before sending the result
   */
  protobuf_c_boolean has_show_display;
  protobuf_c_boolean show_display;
  /*
   * Filled if we are showing a multisig address
   */
  MultisigRedeemScriptType *multisig;
};
extern char get_address__coin_name__default_value[];
#define GET_ADDRESS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&get_address__descriptor) \
    , 0,NULL, get_address__coin_name__default_value, 0,0, NULL }


/*
 **
 * Request: Ask device for Ethereum address corresponding to address_n path
 * @next PassphraseRequest
 * @next EthereumAddress
 * @next Failure
 */
struct  _EthereumGetAddress
{
  ProtobufCMessage base;
  /*
   * BIP-32 path to derive the key from master node
   */
  size_t n_address_n;
  uint32_t *address_n;
  /*
   * optionally show on display before sending the result
   */
  protobuf_c_boolean has_show_display;
  protobuf_c_boolean show_display;
};
#define ETHEREUM_GET_ADDRESS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&ethereum_get_address__descriptor) \
    , 0,NULL, 0,0 }


/*
 **
 * Response: Contains address derived from device private seed
 * @prev GetAddress
 */
struct  _Address
{
  ProtobufCMessage base;
  /*
   * Coin address in Base58 encoding
   */
  char *address;
};
#define ADDRESS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&address__descriptor) \
    , NULL }


/*
 **
 * Response: Contains an Ethereum address derived from device private seed
 * @prev EthereumGetAddress
 */
struct  _EthereumAddress
{
  ProtobufCMessage base;
  /*
   * Coin address as an Ethereum 160 bit hash
   */
  ProtobufCBinaryData address;
};
#define ETHEREUM_ADDRESS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&ethereum_address__descriptor) \
    , {0,NULL} }


/*
 **
 * Request: Request device to wipe all sensitive data and settings
 * @next ButtonRequest
 */
struct  _WipeDevice
{
  ProtobufCMessage base;
};
#define WIPE_DEVICE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&wipe_device__descriptor) \
     }


/*
 **
 * Request: Load seed and related internal settings from the computer
 * @next ButtonRequest
 * @next Success
 * @next Failure
 */
struct  _LoadDevice
{
  ProtobufCMessage base;
  /*
   * seed encoded as BIP-39 mnemonic (12, 18 or 24 words)
   */
  char *mnemonic;
  /*
   * BIP-32 node
   */
  HDNodeType *node;
  /*
   * set PIN protection
   */
  char *pin;
  /*
   * enable master node encryption using passphrase
   */
  protobuf_c_boolean has_passphrase_protection;
  protobuf_c_boolean passphrase_protection;
  /*
   * device language
   */
  char *language;
  /*
   * device label
   */
  char *label;
  /*
   * do not test mnemonic for valid BIP-39 checksum
   */
  protobuf_c_boolean has_skip_checksum;
  protobuf_c_boolean skip_checksum;
};
extern char load_device__language__default_value[];
#define LOAD_DEVICE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&load_device__descriptor) \
    , NULL, NULL, NULL, 0,0, load_device__language__default_value, NULL, 0,0 }


/*
 **
 * Request: Ask device to do initialization involving user interaction
 * @next EntropyRequest
 * @next Failure
 */
struct  _ResetDevice
{
  ProtobufCMessage base;
  /*
   * display entropy generated by the device before asking for additional entropy
   */
  protobuf_c_boolean has_display_random;
  protobuf_c_boolean display_random;
  /*
   * strength of seed in bits
   */
  protobuf_c_boolean has_strength;
  uint32_t strength;
  /*
   * enable master node encryption using passphrase
   */
  protobuf_c_boolean has_passphrase_protection;
  protobuf_c_boolean passphrase_protection;
  /*
   * enable PIN protection
   */
  protobuf_c_boolean has_pin_protection;
  protobuf_c_boolean pin_protection;
  /*
   * device language
   */
  char *language;
  /*
   * device label
   */
  char *label;
};
extern char reset_device__language__default_value[];
#define RESET_DEVICE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&reset_device__descriptor) \
    , 0,0, 0,256u, 0,0, 0,0, reset_device__language__default_value, NULL }


/*
 **
 * Response: Ask for additional entropy from host computer
 * @prev ResetDevice
 * @next EntropyAck
 */
struct  _EntropyRequest
{
  ProtobufCMessage base;
};
#define ENTROPY_REQUEST__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&entropy_request__descriptor) \
     }


/*
 **
 * Request: Provide additional entropy for seed generation function
 * @prev EntropyRequest
 * @next ButtonRequest
 */
struct  _EntropyAck
{
  ProtobufCMessage base;
  /*
   * 256 bits (32 bytes) of random data
   */
  protobuf_c_boolean has_entropy;
  ProtobufCBinaryData entropy;
};
#define ENTROPY_ACK__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&entropy_ack__descriptor) \
    , 0,{0,NULL} }


/*
 **
 * Request: Start recovery workflow asking user for specific words of mnemonic
 * Used to recovery device safely even on untrusted computer.
 * @next WordRequest
 */
struct  _RecoveryDevice
{
  ProtobufCMessage base;
  /*
   * number of words in BIP-39 mnemonic
   */
  protobuf_c_boolean has_word_count;
  uint32_t word_count;
  /*
   * enable master node encryption using passphrase
   */
  protobuf_c_boolean has_passphrase_protection;
  protobuf_c_boolean passphrase_protection;
  /*
   * enable PIN protection
   */
  protobuf_c_boolean has_pin_protection;
  protobuf_c_boolean pin_protection;
  /*
   * device language
   */
  char *language;
  /*
   * device label
   */
  char *label;
  /*
   * enforce BIP-39 wordlist during the process
   */
  protobuf_c_boolean has_enforce_wordlist;
  protobuf_c_boolean enforce_wordlist;
};
extern char recovery_device__language__default_value[];
#define RECOVERY_DEVICE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&recovery_device__descriptor) \
    , 0,0, 0,0, 0,0, recovery_device__language__default_value, NULL, 0,0 }


/*
 **
 * Response: Device is waiting for user to enter word of the mnemonic
 * Its position is shown only on device's internal display.
 * @prev RecoveryDevice
 * @prev WordAck
 */
struct  _WordRequest
{
  ProtobufCMessage base;
};
#define WORD_REQUEST__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&word_request__descriptor) \
     }


/*
 **
 * Request: Computer replies with word from the mnemonic
 * @prev WordRequest
 * @next WordRequest
 * @next Success
 * @next Failure
 */
struct  _WordAck
{
  ProtobufCMessage base;
  /*
   * one word of mnemonic on asked position
   */
  char *word;
};
#define WORD_ACK__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&word_ack__descriptor) \
    , NULL }


/*
 **
 * Request: Ask device to sign message
 * @next MessageSignature
 * @next Failure
 */
struct  _SignMessage
{
  ProtobufCMessage base;
  /*
   * BIP-32 path to derive the key from master node
   */
  size_t n_address_n;
  uint32_t *address_n;
  /*
   * message to be signed
   */
  ProtobufCBinaryData message;
  /*
   * coin to use for signing
   */
  char *coin_name;
};
extern char sign_message__coin_name__default_value[];
#define SIGN_MESSAGE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&sign_message__descriptor) \
    , 0,NULL, {0,NULL}, sign_message__coin_name__default_value }


/*
 **
 * Request: Ask device to verify message
 * @next Success
 * @next Failure
 */
struct  _VerifyMessage
{
  ProtobufCMessage base;
  /*
   * address to verify
   */
  char *address;
  /*
   * signature to verify
   */
  protobuf_c_boolean has_signature;
  ProtobufCBinaryData signature;
  /*
   * message to verify
   */
  protobuf_c_boolean has_message;
  ProtobufCBinaryData message;
  /*
   * coin to use for verifying
   */
  char *coin_name;
};
extern char verify_message__coin_name__default_value[];
#define VERIFY_MESSAGE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&verify_message__descriptor) \
    , NULL, 0,{0,NULL}, 0,{0,NULL}, verify_message__coin_name__default_value }


/*
 **
 * Response: Signed message
 * @prev SignMessage
 */
struct  _MessageSignature
{
  ProtobufCMessage base;
  /*
   * address used to sign the message
   */
  char *address;
  /*
   * signature of the message
   */
  protobuf_c_boolean has_signature;
  ProtobufCBinaryData signature;
};
#define MESSAGE_SIGNATURE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&message_signature__descriptor) \
    , NULL, 0,{0,NULL} }


/*
 **
 * Request: Ask device to encrypt message
 * @next EncryptedMessage
 * @next Failure
 */
struct  _EncryptMessage
{
  ProtobufCMessage base;
  /*
   * public key
   */
  protobuf_c_boolean has_pubkey;
  ProtobufCBinaryData pubkey;
  /*
   * message to encrypt
   */
  protobuf_c_boolean has_message;
  ProtobufCBinaryData message;
  /*
   * show just on display? (don't send back via wire)
   */
  protobuf_c_boolean has_display_only;
  protobuf_c_boolean display_only;
  /*
   * BIP-32 path to derive the signing key from master node
   */
  size_t n_address_n;
  uint32_t *address_n;
  /*
   * coin to use for signing
   */
  char *coin_name;
};
extern char encrypt_message__coin_name__default_value[];
#define ENCRYPT_MESSAGE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&encrypt_message__descriptor) \
    , 0,{0,NULL}, 0,{0,NULL}, 0,0, 0,NULL, encrypt_message__coin_name__default_value }


/*
 **
 * Response: Encrypted message
 * @prev EncryptMessage
 */
struct  _EncryptedMessage
{
  ProtobufCMessage base;
  /*
   * nonce used during encryption
   */
  protobuf_c_boolean has_nonce;
  ProtobufCBinaryData nonce;
  /*
   * encrypted message
   */
  protobuf_c_boolean has_message;
  ProtobufCBinaryData message;
  /*
   * message hmac
   */
  protobuf_c_boolean has_hmac;
  ProtobufCBinaryData hmac;
};
#define ENCRYPTED_MESSAGE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&encrypted_message__descriptor) \
    , 0,{0,NULL}, 0,{0,NULL}, 0,{0,NULL} }


/*
 **
 * Request: Ask device to decrypt message
 * @next Success
 * @next Failure
 */
struct  _DecryptMessage
{
  ProtobufCMessage base;
  /*
   * BIP-32 path to derive the decryption key from master node
   */
  size_t n_address_n;
  uint32_t *address_n;
  /*
   * nonce used during encryption
   */
  protobuf_c_boolean has_nonce;
  ProtobufCBinaryData nonce;
  /*
   * message to decrypt
   */
  protobuf_c_boolean has_message;
  ProtobufCBinaryData message;
  /*
   * message hmac
   */
  protobuf_c_boolean has_hmac;
  ProtobufCBinaryData hmac;
};
#define DECRYPT_MESSAGE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&decrypt_message__descriptor) \
    , 0,NULL, 0,{0,NULL}, 0,{0,NULL}, 0,{0,NULL} }


/*
 **
 * Response: Decrypted message
 * @prev DecryptedMessage
 */
struct  _DecryptedMessage
{
  ProtobufCMessage base;
  /*
   * decrypted message
   */
  protobuf_c_boolean has_message;
  ProtobufCBinaryData message;
  /*
   * address used to sign the message (if used)
   */
  char *address;
};
#define DECRYPTED_MESSAGE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&decrypted_message__descriptor) \
    , 0,{0,NULL}, NULL }


/*
 **
 * Request: Ask device to encrypt or decrypt value of given key
 * @next CipheredKeyValue
 * @next Failure
 */
struct  _CipherKeyValue
{
  ProtobufCMessage base;
  /*
   * BIP-32 path to derive the key from master node
   */
  size_t n_address_n;
  uint32_t *address_n;
  /*
   * key component of key:value
   */
  char *key;
  /*
   * value component of key:value
   */
  protobuf_c_boolean has_value;
  ProtobufCBinaryData value;
  /*
   * are we encrypting (True) or decrypting (False)?
   */
  protobuf_c_boolean has_encrypt;
  protobuf_c_boolean encrypt;
  /*
   * should we ask on encrypt operation?
   */
  protobuf_c_boolean has_ask_on_encrypt;
  protobuf_c_boolean ask_on_encrypt;
  /*
   * should we ask on decrypt operation?
   */
  protobuf_c_boolean has_ask_on_decrypt;
  protobuf_c_boolean ask_on_decrypt;
  /*
   * initialization vector (will be computed if not set)
   */
  protobuf_c_boolean has_iv;
  ProtobufCBinaryData iv;
};
#define CIPHER_KEY_VALUE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cipher_key_value__descriptor) \
    , 0,NULL, NULL, 0,{0,NULL}, 0,0, 0,0, 0,0, 0,{0,NULL} }


/*
 **
 * Response: Return ciphered/deciphered value
 * @prev CipherKeyValue
 */
struct  _CipheredKeyValue
{
  ProtobufCMessage base;
  /*
   * ciphered/deciphered value
   */
  protobuf_c_boolean has_value;
  ProtobufCBinaryData value;
};
#define CIPHERED_KEY_VALUE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&ciphered_key_value__descriptor) \
    , 0,{0,NULL} }


/*
 **
 * Request:  Estimated size of the transaction
 * This behaves exactly like SignTx, which means that it can ask using TxRequest
 * This call is non-blocking (except possible PassphraseRequest to unlock the seed)
 * @next TxSize
 * @next Failure
 */
struct  _EstimateTxSize
{
  ProtobufCMessage base;
  /*
   * number of transaction outputs
   */
  uint32_t outputs_count;
  /*
   * number of transaction inputs
   */
  uint32_t inputs_count;
  /*
   * coin to use
   */
  char *coin_name;
};
extern char estimate_tx_size__coin_name__default_value[];
#define ESTIMATE_TX_SIZE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&estimate_tx_size__descriptor) \
    , 0, 0, estimate_tx_size__coin_name__default_value }


/*
 **
 * Response: Estimated size of the transaction
 * @prev EstimateTxSize
 */
struct  _TxSize
{
  ProtobufCMessage base;
  /*
   * estimated size of transaction in bytes
   */
  protobuf_c_boolean has_tx_size;
  uint32_t tx_size;
};
#define TX_SIZE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tx_size__descriptor) \
    , 0,0 }


/*
 **
 * Request: Ask device to sign transaction
 * @next PassphraseRequest
 * @next PinMatrixRequest
 * @next TxRequest
 * @next Failure
 */
struct  _SignTx
{
  ProtobufCMessage base;
  /*
   * number of transaction outputs
   */
  uint32_t outputs_count;
  /*
   * number of transaction inputs
   */
  uint32_t inputs_count;
  /*
   * coin to use
   */
  char *coin_name;
  /*
   * transaction version
   */
  protobuf_c_boolean has_version;
  uint32_t version;
  /*
   * transaction lock_time
   */
  protobuf_c_boolean has_lock_time;
  uint32_t lock_time;
};
extern char sign_tx__coin_name__default_value[];
#define SIGN_TX__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&sign_tx__descriptor) \
    , 0, 0, sign_tx__coin_name__default_value, 0,1u, 0,0u }


/*
 **
 * Request: Simplified transaction signing
 * This method doesn't support streaming, so there are hardware limits in number of inputs and outputs.
 * In case of success, the result is returned using TxRequest message.
 * @next PassphraseRequest
 * @next PinMatrixRequest
 * @next TxRequest
 * @next Failure
 */
struct  _SimpleSignTx
{
  ProtobufCMessage base;
  /*
   * transaction inputs
   */
  size_t n_inputs;
  TxInputType **inputs;
  /*
   * transaction outputs
   */
  size_t n_outputs;
  TxOutputType **outputs;
  /*
   * transactions whose outputs are used to build current inputs
   */
  size_t n_transactions;
  TransactionType **transactions;
  /*
   * coin to use
   */
  char *coin_name;
  /*
   * transaction version
   */
  protobuf_c_boolean has_version;
  uint32_t version;
  /*
   * transaction lock_time
   */
  protobuf_c_boolean has_lock_time;
  uint32_t lock_time;
};
extern char simple_sign_tx__coin_name__default_value[];
#define SIMPLE_SIGN_TX__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&simple_sign_tx__descriptor) \
    , 0,NULL, 0,NULL, 0,NULL, simple_sign_tx__coin_name__default_value, 0,1u, 0,0u }


/*
 **
 * Response: Device asks for information for signing transaction or returns the last result
 * If request_index is set, device awaits TxAck message (with fields filled in according to request_type)
 * If signature_index is set, 'signature' contains signed input of signature_index's input
 * @prev SignTx
 * @prev SimpleSignTx
 * @prev TxAck
 */
struct  _TxRequest
{
  ProtobufCMessage base;
  /*
   * what should be filled in TxAck message?
   */
  protobuf_c_boolean has_request_type;
  RequestType request_type;
  /*
   * request for tx details
   */
  TxRequestDetailsType *details;
  /*
   * serialized data and request for next
   */
  TxRequestSerializedType *serialized;
};
#define TX_REQUEST__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tx_request__descriptor) \
    , 0,0, NULL, NULL }


/*
 **
 * Request: Reported transaction data
 * @prev TxRequest
 * @next TxRequest
 */
struct  _TxAck
{
  ProtobufCMessage base;
  TransactionType *tx;
};
#define TX_ACK__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tx_ack__descriptor) \
    , NULL }


/*
 **
 * Request: Ask device to sign transaction
 * All fields are optional from the protocol's point of view. Each field defaults to value `0` if missing.
 * Note: the first at most 1024 bytes of data MUST be transmitted as part of this message.
 * @next PassphraseRequest
 * @next PinMatrixRequest
 * @next EthereumTxRequest
 * @next Failure
 */
struct  _EthereumSignTx
{
  ProtobufCMessage base;
  /*
   * BIP-32 path to derive the key from master node
   */
  size_t n_address_n;
  uint32_t *address_n;
  /*
   * <=256 bit unsigned big endian
   */
  protobuf_c_boolean has_nonce;
  ProtobufCBinaryData nonce;
  /*
   * <=256 bit unsigned big endian (in wei)
   */
  protobuf_c_boolean has_gas_price;
  ProtobufCBinaryData gas_price;
  /*
   * <=256 bit unsigned big endian
   */
  protobuf_c_boolean has_gas_limit;
  ProtobufCBinaryData gas_limit;
  /*
   * 160 bit address hash
   */
  protobuf_c_boolean has_to;
  ProtobufCBinaryData to;
  /*
   * <=256 bit unsigned big endian (in wei)
   */
  protobuf_c_boolean has_value;
  ProtobufCBinaryData value;
  /*
   * The initial data chunk (<= 1024 bytes)
   */
  protobuf_c_boolean has_data_initial_chunk;
  ProtobufCBinaryData data_initial_chunk;
  /*
   * Length of transaction payload
   */
  protobuf_c_boolean has_data_length;
  uint32_t data_length;
};
#define ETHEREUM_SIGN_TX__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&ethereum_sign_tx__descriptor) \
    , 0,NULL, 0,{0,NULL}, 0,{0,NULL}, 0,{0,NULL}, 0,{0,NULL}, 0,{0,NULL}, 0,{0,NULL}, 0,0 }


/*
 **
 * Response: Device asks for more data from transaction payload, or returns the signature.
 * If data_length is set, device awaits that many more bytes of payload.
 * Otherwise, the signature_* fields contain the computed transaction signature. All three fields will be present.
 * @prev EthereumSignTx
 * @next EthereumTxAck
 */
struct  _EthereumTxRequest
{
  ProtobufCMessage base;
  /*
   * Number of bytes being requested (<= 1024)
   */
  protobuf_c_boolean has_data_length;
  uint32_t data_length;
  /*
   * Computed signature (recovery parameter, limited to 27 or 28)
   */
  protobuf_c_boolean has_signature_v;
  uint32_t signature_v;
  /*
   * Computed signature R component (256 bit)
   */
  protobuf_c_boolean has_signature_r;
  ProtobufCBinaryData signature_r;
  /*
   * Computed signature S component (256 bit)
   */
  protobuf_c_boolean has_signature_s;
  ProtobufCBinaryData signature_s;
};
#define ETHEREUM_TX_REQUEST__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&ethereum_tx_request__descriptor) \
    , 0,0, 0,0, 0,{0,NULL}, 0,{0,NULL} }


/*
 **
 * Request: Transaction payload data.
 * @prev EthereumTxRequest
 * @next EthereumTxRequest
 */
struct  _EthereumTxAck
{
  ProtobufCMessage base;
  /*
   * Bytes from transaction payload (<= 1024 bytes)
   */
  protobuf_c_boolean has_data_chunk;
  ProtobufCBinaryData data_chunk;
};
#define ETHEREUM_TX_ACK__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&ethereum_tx_ack__descriptor) \
    , 0,{0,NULL} }


/*
 **
 * Request: Ask device to sign identity
 * @next SignedIdentity
 * @next Failure
 */
struct  _SignIdentity
{
  ProtobufCMessage base;
  /*
   * identity
   */
  IdentityType *identity;
  /*
   * non-visible challenge
   */
  protobuf_c_boolean has_challenge_hidden;
  ProtobufCBinaryData challenge_hidden;
  /*
   * challenge shown on display (e.g. date+time)
   */
  char *challenge_visual;
  /*
   * ECDSA curve name to use
   */
  char *ecdsa_curve_name;
};
#define SIGN_IDENTITY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&sign_identity__descriptor) \
    , NULL, 0,{0,NULL}, NULL, NULL }


/*
 **
 * Response: Device provides signed identity
 * @prev SignIdentity
 */
struct  _SignedIdentity
{
  ProtobufCMessage base;
  /*
   * identity address
   */
  char *address;
  /*
   * identity public key
   */
  protobuf_c_boolean has_public_key;
  ProtobufCBinaryData public_key;
  /*
   * signature of the identity data
   */
  protobuf_c_boolean has_signature;
  ProtobufCBinaryData signature;
};
#define SIGNED_IDENTITY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&signed_identity__descriptor) \
    , NULL, 0,{0,NULL}, 0,{0,NULL} }


/*
 **
 * Request: Ask device to generate ECDH session key
 * @next ECDHSessionKey
 * @next Failure
 */
struct  _GetECDHSessionKey
{
  ProtobufCMessage base;
  /*
   * identity
   */
  IdentityType *identity;
  /*
   * peer's public key
   */
  protobuf_c_boolean has_peer_public_key;
  ProtobufCBinaryData peer_public_key;
  /*
   * ECDSA curve name to use
   */
  char *ecdsa_curve_name;
};
#define GET_ECDHSESSION_KEY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&get_ecdhsession_key__descriptor) \
    , NULL, 0,{0,NULL}, NULL }


/*
 **
 * Response: Device provides ECDH session key
 * @prev GetECDHSessionKey
 */
struct  _ECDHSessionKey
{
  ProtobufCMessage base;
  /*
   * ECDH session key
   */
  protobuf_c_boolean has_session_key;
  ProtobufCBinaryData session_key;
};
#define ECDHSESSION_KEY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&ecdhsession_key__descriptor) \
    , 0,{0,NULL} }


/*
 **
 * Request: Set U2F counter
 * @next Success
 */
struct  _SetU2FCounter
{
  ProtobufCMessage base;
  /*
   * counter
   */
  protobuf_c_boolean has_u2f_counter;
  uint32_t u2f_counter;
};
#define SET_U2_FCOUNTER__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&set_u2_fcounter__descriptor) \
    , 0,0 }


/*
 **
 * Request: Ask device to erase its firmware
 * @next Success
 * @next Failure
 */
struct  _FirmwareErase
{
  ProtobufCMessage base;
};
#define FIRMWARE_ERASE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&firmware_erase__descriptor) \
     }


/*
 **
 * Request: Send firmware in binary form to the device
 * @next Success
 * @next Failure
 */
struct  _FirmwareUpload
{
  ProtobufCMessage base;
  /*
   * firmware to be loaded into device
   */
  ProtobufCBinaryData payload;
};
#define FIRMWARE_UPLOAD__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&firmware_upload__descriptor) \
    , {0,NULL} }


/*
 **
 * Request: "Press" the button on the device
 * @next Success
 */
struct  _DebugLinkDecision
{
  ProtobufCMessage base;
  /*
   * true for "Confirm", false for "Cancel"
   */
  protobuf_c_boolean yes_no;
};
#define DEBUG_LINK_DECISION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&debug_link_decision__descriptor) \
    , 0 }


/*
 **
 * Request: Computer asks for device state
 * @next DebugLinkState
 */
struct  _DebugLinkGetState
{
  ProtobufCMessage base;
};
#define DEBUG_LINK_GET_STATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&debug_link_get_state__descriptor) \
     }


/*
 **
 * Response: Device current state
 * @prev DebugLinkGetState
 */
struct  _DebugLinkState
{
  ProtobufCMessage base;
  /*
   * raw buffer of display
   */
  protobuf_c_boolean has_layout;
  ProtobufCBinaryData layout;
  /*
   * current PIN, blank if PIN is not set/enabled
   */
  char *pin;
  /*
   * current PIN matrix
   */
  char *matrix;
  /*
   * current BIP-39 mnemonic
   */
  char *mnemonic;
  /*
   * current BIP-32 node
   */
  HDNodeType *node;
  /*
   * is node/mnemonic encrypted using passphrase?
   */
  protobuf_c_boolean has_passphrase_protection;
  protobuf_c_boolean passphrase_protection;
  /*
   * word on device display during ResetDevice workflow
   */
  char *reset_word;
  /*
   * current entropy during ResetDevice workflow
   */
  protobuf_c_boolean has_reset_entropy;
  ProtobufCBinaryData reset_entropy;
  /*
   * (fake) word on display during RecoveryDevice workflow
   */
  char *recovery_fake_word;
  /*
   * index of mnemonic word the device is expecting during RecoveryDevice workflow
   */
  protobuf_c_boolean has_recovery_word_pos;
  uint32_t recovery_word_pos;
  /*
   * current xmr secret key
   */
  protobuf_c_boolean has_xmr_seckey;
  ProtobufCBinaryData xmr_seckey;
};
#define DEBUG_LINK_STATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&debug_link_state__descriptor) \
    , 0,{0,NULL}, NULL, NULL, NULL, NULL, 0,0, NULL, 0,{0,NULL}, NULL, 0,0, 0,{0,NULL} }


/*
 **
 * Request: Ask device to restart
 */
struct  _DebugLinkStop
{
  ProtobufCMessage base;
};
#define DEBUG_LINK_STOP__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&debug_link_stop__descriptor) \
     }


/*
 **
 * Response: Device wants host to log event
 */
struct  _DebugLinkLog
{
  ProtobufCMessage base;
  protobuf_c_boolean has_level;
  uint32_t level;
  char *bucket;
  char *text;
};
#define DEBUG_LINK_LOG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&debug_link_log__descriptor) \
    , 0,0, NULL, NULL }


/*
 **
 * Request: Read memory from device
 * @next DebugLinkMemory
 */
struct  _DebugLinkMemoryRead
{
  ProtobufCMessage base;
  protobuf_c_boolean has_address;
  uint32_t address;
  protobuf_c_boolean has_length;
  uint32_t length;
};
#define DEBUG_LINK_MEMORY_READ__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&debug_link_memory_read__descriptor) \
    , 0,0, 0,0 }


/*
 **
 * Response: Device sends memory back
 * @prev DebugLinkMemoryRead
 */
struct  _DebugLinkMemory
{
  ProtobufCMessage base;
  protobuf_c_boolean has_memory;
  ProtobufCBinaryData memory;
};
#define DEBUG_LINK_MEMORY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&debug_link_memory__descriptor) \
    , 0,{0,NULL} }


/*
 **
 * Request: Write memory to device.  WARNING: Writing to the wrong
 * location can irreparably break the device.
 */
struct  _DebugLinkMemoryWrite
{
  ProtobufCMessage base;
  protobuf_c_boolean has_address;
  uint32_t address;
  protobuf_c_boolean has_memory;
  ProtobufCBinaryData memory;
  protobuf_c_boolean has_flash;
  protobuf_c_boolean flash;
};
#define DEBUG_LINK_MEMORY_WRITE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&debug_link_memory_write__descriptor) \
    , 0,0, 0,{0,NULL}, 0,0 }


/*
 **
 * Request: Erase block of flash on device.  WARNING: Writing to the wrong
 * location can irreparably break the device.
 */
struct  _DebugLinkFlashErase
{
  ProtobufCMessage base;
  protobuf_c_boolean has_sector;
  uint32_t sector;
};
#define DEBUG_LINK_FLASH_ERASE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&debug_link_flash_erase__descriptor) \
    , 0,0 }


/*
 **
 * Request: Request XMR session public key
 * @next XmrRequestSessionKeyAck
 */
struct  _XmrRequestSessionKey
{
  ProtobufCMessage base;
  /*
   * requesters public key
   */
  ProtobufCBinaryData pubkey;
};
#define XMR_REQUEST_SESSION_KEY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&xmr_request_session_key__descriptor) \
    , {0,NULL} }


/*
 **
 * Response: Ack XMR session public key 
 * @next ButtonAck
 * @next Cancel
 */
struct  _XmrRequestSessionKeyAck
{
  ProtobufCMessage base;
  /*
   * responders public key
   */
  ProtobufCBinaryData pubkey;
};
#define XMR_REQUEST_SESSION_KEY_ACK__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&xmr_request_session_key_ack__descriptor) \
    , {0,NULL} }


/*
 **
 * Request: Request XMR viewkey
 * @next XmrRequestViewKeyAck
 */
struct  _XmrRequestViewKey
{
  ProtobufCMessage base;
  /*
   * index of account
   */
  uint32_t account_index;
  /*
   * optional passphrase
   */
  char *passphrase;
  /*
   * show address 
   */
  protobuf_c_boolean display_address;
};
#define XMR_REQUEST_VIEW_KEY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&xmr_request_view_key__descriptor) \
    , 0, NULL, 0 }


/*
 **
 * Response: Ack XMR session public key
 */
struct  _XmrRequestViewKeyAck
{
  ProtobufCMessage base;
  /*
   * responders sec viewkey
   */
  ProtobufCBinaryData viewkey;
  /*
   * responders pub spendkey
   */
  ProtobufCBinaryData spendkey;
  /*
   * checksum
   */
  uint32_t checksum;
};
#define XMR_REQUEST_VIEW_KEY_ACK__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&xmr_request_view_key_ack__descriptor) \
    , {0,NULL}, {0,NULL}, 0 }


/*
 **
 * Request: Request key_image
 * @next XmrGenerateImageAck
 */
struct  _XmrGenerateKeyImage
{
  ProtobufCMessage base;
  /*
   * key derivation
   */
  ProtobufCBinaryData derivation;
  /*
   * ephemeral public key
   */
  ProtobufCBinaryData eph_pubkey;
  /*
   * index in outputs vector
   */
  ProtobufCBinaryData indices;
  /*
   * number of key_images 
   */
  uint32_t count;
};
#define XMR_GENERATE_KEY_IMAGE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&xmr_generate_key_image__descriptor) \
    , {0,NULL}, {0,NULL}, {0,NULL}, 0 }


/*
 **
 * Response: Ack request signature and key_image
 */
struct  _XmrGenerateKeyImageAck
{
  ProtobufCMessage base;
  /*
   * resulting key_image
   */
  ProtobufCBinaryData key_image;
  /*
   * checksum
   */
  uint32_t checksum;
};
#define XMR_GENERATE_KEY_IMAGE_ACK__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&xmr_generate_key_image_ack__descriptor) \
    , {0,NULL}, 0 }


/*
 **
 * Request: Request signature
 * @next XmrGenerateSignatureAck
 */
struct  _XmrGenerateSignature
{
  ProtobufCMessage base;
  /*
   * current tx generation id
   */
  uint64_t txid;
  /*
   * signature data to be signed
   */
  size_t n_data;
  XmrSignatureType **data;
  /*
   * version of signature function to use
   */
  uint64_t version;
};
#define XMR_GENERATE_SIGNATURE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&xmr_generate_signature__descriptor) \
    , 0, 0,NULL, 0 }


/*
 **
 * Response: Ack request signature
 */
struct  _XmrGenerateSignatureAck
{
  ProtobufCMessage base;
  /*
   * sig.c
   */
  ProtobufCBinaryData c;
  /*
   * sig.r
   */
  ProtobufCBinaryData r;
  /*
   * tx secret key
   */
  protobuf_c_boolean has_tx_seckey;
  ProtobufCBinaryData tx_seckey;
  /*
   * checksum
   */
  uint32_t checksum;
};
#define XMR_GENERATE_SIGNATURE_ACK__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&xmr_generate_signature_ack__descriptor) \
    , {0,NULL}, {0,NULL}, 0,{0,NULL}, 0 }


/*
 **
 * Request: Initialize tx generation
 * @next XmrGenerateTxInitAck
 */
struct  _XmrGenerateTxInit
{
  ProtobufCMessage base;
  /*
   * version
   */
  uint64_t version;
  /*
   * unlock time
   */
  uint64_t unlock_time;
  /*
   * vin count
   */
  uint32_t vin_count;
  /*
   * vout count
   */
  uint32_t vout_count;
  /*
   * mixin
   */
  uint32_t mixin;
  /*
   * list of external addreses [0:31 spend, 32:63, view] 
   */
  protobuf_c_boolean has_dest_addresses;
  ProtobufCBinaryData dest_addresses;
  /*
   * fee per kb
   */
  uint64_t tx_fee;
};
#define XMR_GENERATE_TX_INIT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&xmr_generate_tx_init__descriptor) \
    , 0, 0, 0, 0, 0, 0,{0,NULL}, 0 }


/*
 **
 * Response: Initialize tx generation ack
 */
struct  _XmrGenerateTxInitAck
{
  ProtobufCMessage base;
  /*
   * current tx generation id
   */
  uint64_t txid;
  /*
   * tx secret_key
   */
  ProtobufCBinaryData tx_seckey;
};
#define XMR_GENERATE_TX_INIT_ACK__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&xmr_generate_tx_init_ack__descriptor) \
    , 0, {0,NULL} }


/*
 **
 * Request: Send tx extra and request prefix_hash
 * @next XmrGenerateTxExtraAck
 */
struct  _XmrGenerateTxExtra
{
  ProtobufCMessage base;
  /*
   * current tx generation id
   */
  uint64_t txid;
  /*
   * initial or additional
   */
  protobuf_c_boolean initial;
  /*
   * payment_id (size = 0 means no payment_id)
   */
  protobuf_c_boolean has_payment_id;
  ProtobufCBinaryData payment_id;
  /*
   * payment_id version
   */
  protobuf_c_boolean has_payment_id_ver;
  uint32_t payment_id_ver;
};
#define XMR_GENERATE_TX_EXTRA__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&xmr_generate_tx_extra__descriptor) \
    , 0, 0, 0,{0,NULL}, 0,0 }


/*
 **
 * Response: Send tx extra and request prefix_hash
 */
struct  _XmrGenerateTxExtraAck
{
  ProtobufCMessage base;
  /*
   * prefix_hash
   */
  ProtobufCBinaryData prefix_hash;
  /*
   * extra bytes, payment_id is encrypted if V2. Max is 68 bytes for now
   */
  ProtobufCBinaryData extra;
};
#define XMR_GENERATE_TX_EXTRA_ACK__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&xmr_generate_tx_extra_ack__descriptor) \
    , {0,NULL}, {0,NULL} }


/*
 **
 * Request: Request Vin key_images
 * @next XmrGenerateTxVinAck
 */
struct  _XmrGenerateTxVin
{
  ProtobufCMessage base;
  /*
   * current tx generation id
   */
  uint64_t txid;
  /*
   * initial or additional
   */
  protobuf_c_boolean initial;
  /*
   * vins
   */
  size_t n_ins;
  XmrInputType **ins;
};
#define XMR_GENERATE_TX_VIN__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&xmr_generate_tx_vin__descriptor) \
    , 0, 0, 0,NULL }


/*
 **
 * Response: Request Vin key_images ack
 */
struct  _XmrGenerateTxVinAck
{
  ProtobufCMessage base;
  /*
   * key_images
   */
  ProtobufCBinaryData key_images;
};
#define XMR_GENERATE_TX_VIN_ACK__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&xmr_generate_tx_vin_ack__descriptor) \
    , {0,NULL} }


/*
 **
 * Request: Request vout public_keys
 * @next XmrGenerateTxVout
 */
struct  _XmrGenerateTxVout
{
  ProtobufCMessage base;
  /*
   * current tx generation id
   */
  uint64_t txid;
  /*
   * initial or additional
   */
  protobuf_c_boolean initial;
  /*
   * vouts
   */
  size_t n_outs;
  XmrOutputType **outs;
};
#define XMR_GENERATE_TX_VOUT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&xmr_generate_tx_vout__descriptor) \
    , 0, 0, 0,NULL }


/*
 **
 * Response: Request vout public_keys ack
 */
struct  _XmrGenerateTxVoutAck
{
  ProtobufCMessage base;
  /*
   * output public keys
   */
  ProtobufCBinaryData pubkeys;
};
#define XMR_GENERATE_TX_VOUT_ACK__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&xmr_generate_tx_vout_ack__descriptor) \
    , {0,NULL} }


/* Initialize methods */
void   initialize__init
                     (Initialize         *message);
size_t initialize__get_packed_size
                     (const Initialize   *message);
size_t initialize__pack
                     (const Initialize   *message,
                      uint8_t             *out);
size_t initialize__pack_to_buffer
                     (const Initialize   *message,
                      ProtobufCBuffer     *buffer);
Initialize *
       initialize__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   initialize__free_unpacked
                     (Initialize *message,
                      ProtobufCAllocator *allocator);
/* GetFeatures methods */
void   get_features__init
                     (GetFeatures         *message);
size_t get_features__get_packed_size
                     (const GetFeatures   *message);
size_t get_features__pack
                     (const GetFeatures   *message,
                      uint8_t             *out);
size_t get_features__pack_to_buffer
                     (const GetFeatures   *message,
                      ProtobufCBuffer     *buffer);
GetFeatures *
       get_features__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   get_features__free_unpacked
                     (GetFeatures *message,
                      ProtobufCAllocator *allocator);
/* Features methods */
void   features__init
                     (Features         *message);
size_t features__get_packed_size
                     (const Features   *message);
size_t features__pack
                     (const Features   *message,
                      uint8_t             *out);
size_t features__pack_to_buffer
                     (const Features   *message,
                      ProtobufCBuffer     *buffer);
Features *
       features__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   features__free_unpacked
                     (Features *message,
                      ProtobufCAllocator *allocator);
/* ClearSession methods */
void   clear_session__init
                     (ClearSession         *message);
size_t clear_session__get_packed_size
                     (const ClearSession   *message);
size_t clear_session__pack
                     (const ClearSession   *message,
                      uint8_t             *out);
size_t clear_session__pack_to_buffer
                     (const ClearSession   *message,
                      ProtobufCBuffer     *buffer);
ClearSession *
       clear_session__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   clear_session__free_unpacked
                     (ClearSession *message,
                      ProtobufCAllocator *allocator);
/* ApplySettings methods */
void   apply_settings__init
                     (ApplySettings         *message);
size_t apply_settings__get_packed_size
                     (const ApplySettings   *message);
size_t apply_settings__pack
                     (const ApplySettings   *message,
                      uint8_t             *out);
size_t apply_settings__pack_to_buffer
                     (const ApplySettings   *message,
                      ProtobufCBuffer     *buffer);
ApplySettings *
       apply_settings__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   apply_settings__free_unpacked
                     (ApplySettings *message,
                      ProtobufCAllocator *allocator);
/* ChangePin methods */
void   change_pin__init
                     (ChangePin         *message);
size_t change_pin__get_packed_size
                     (const ChangePin   *message);
size_t change_pin__pack
                     (const ChangePin   *message,
                      uint8_t             *out);
size_t change_pin__pack_to_buffer
                     (const ChangePin   *message,
                      ProtobufCBuffer     *buffer);
ChangePin *
       change_pin__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   change_pin__free_unpacked
                     (ChangePin *message,
                      ProtobufCAllocator *allocator);
/* Ping methods */
void   ping__init
                     (Ping         *message);
size_t ping__get_packed_size
                     (const Ping   *message);
size_t ping__pack
                     (const Ping   *message,
                      uint8_t             *out);
size_t ping__pack_to_buffer
                     (const Ping   *message,
                      ProtobufCBuffer     *buffer);
Ping *
       ping__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   ping__free_unpacked
                     (Ping *message,
                      ProtobufCAllocator *allocator);
/* Success methods */
void   success__init
                     (Success         *message);
size_t success__get_packed_size
                     (const Success   *message);
size_t success__pack
                     (const Success   *message,
                      uint8_t             *out);
size_t success__pack_to_buffer
                     (const Success   *message,
                      ProtobufCBuffer     *buffer);
Success *
       success__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   success__free_unpacked
                     (Success *message,
                      ProtobufCAllocator *allocator);
/* Failure methods */
void   failure__init
                     (Failure         *message);
size_t failure__get_packed_size
                     (const Failure   *message);
size_t failure__pack
                     (const Failure   *message,
                      uint8_t             *out);
size_t failure__pack_to_buffer
                     (const Failure   *message,
                      ProtobufCBuffer     *buffer);
Failure *
       failure__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   failure__free_unpacked
                     (Failure *message,
                      ProtobufCAllocator *allocator);
/* ButtonRequest methods */
void   button_request__init
                     (ButtonRequest         *message);
size_t button_request__get_packed_size
                     (const ButtonRequest   *message);
size_t button_request__pack
                     (const ButtonRequest   *message,
                      uint8_t             *out);
size_t button_request__pack_to_buffer
                     (const ButtonRequest   *message,
                      ProtobufCBuffer     *buffer);
ButtonRequest *
       button_request__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   button_request__free_unpacked
                     (ButtonRequest *message,
                      ProtobufCAllocator *allocator);
/* ButtonAck methods */
void   button_ack__init
                     (ButtonAck         *message);
size_t button_ack__get_packed_size
                     (const ButtonAck   *message);
size_t button_ack__pack
                     (const ButtonAck   *message,
                      uint8_t             *out);
size_t button_ack__pack_to_buffer
                     (const ButtonAck   *message,
                      ProtobufCBuffer     *buffer);
ButtonAck *
       button_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   button_ack__free_unpacked
                     (ButtonAck *message,
                      ProtobufCAllocator *allocator);
/* PinMatrixRequest methods */
void   pin_matrix_request__init
                     (PinMatrixRequest         *message);
size_t pin_matrix_request__get_packed_size
                     (const PinMatrixRequest   *message);
size_t pin_matrix_request__pack
                     (const PinMatrixRequest   *message,
                      uint8_t             *out);
size_t pin_matrix_request__pack_to_buffer
                     (const PinMatrixRequest   *message,
                      ProtobufCBuffer     *buffer);
PinMatrixRequest *
       pin_matrix_request__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   pin_matrix_request__free_unpacked
                     (PinMatrixRequest *message,
                      ProtobufCAllocator *allocator);
/* PinMatrixAck methods */
void   pin_matrix_ack__init
                     (PinMatrixAck         *message);
size_t pin_matrix_ack__get_packed_size
                     (const PinMatrixAck   *message);
size_t pin_matrix_ack__pack
                     (const PinMatrixAck   *message,
                      uint8_t             *out);
size_t pin_matrix_ack__pack_to_buffer
                     (const PinMatrixAck   *message,
                      ProtobufCBuffer     *buffer);
PinMatrixAck *
       pin_matrix_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   pin_matrix_ack__free_unpacked
                     (PinMatrixAck *message,
                      ProtobufCAllocator *allocator);
/* Cancel methods */
void   cancel__init
                     (Cancel         *message);
size_t cancel__get_packed_size
                     (const Cancel   *message);
size_t cancel__pack
                     (const Cancel   *message,
                      uint8_t             *out);
size_t cancel__pack_to_buffer
                     (const Cancel   *message,
                      ProtobufCBuffer     *buffer);
Cancel *
       cancel__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cancel__free_unpacked
                     (Cancel *message,
                      ProtobufCAllocator *allocator);
/* PassphraseRequest methods */
void   passphrase_request__init
                     (PassphraseRequest         *message);
size_t passphrase_request__get_packed_size
                     (const PassphraseRequest   *message);
size_t passphrase_request__pack
                     (const PassphraseRequest   *message,
                      uint8_t             *out);
size_t passphrase_request__pack_to_buffer
                     (const PassphraseRequest   *message,
                      ProtobufCBuffer     *buffer);
PassphraseRequest *
       passphrase_request__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   passphrase_request__free_unpacked
                     (PassphraseRequest *message,
                      ProtobufCAllocator *allocator);
/* PassphraseAck methods */
void   passphrase_ack__init
                     (PassphraseAck         *message);
size_t passphrase_ack__get_packed_size
                     (const PassphraseAck   *message);
size_t passphrase_ack__pack
                     (const PassphraseAck   *message,
                      uint8_t             *out);
size_t passphrase_ack__pack_to_buffer
                     (const PassphraseAck   *message,
                      ProtobufCBuffer     *buffer);
PassphraseAck *
       passphrase_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   passphrase_ack__free_unpacked
                     (PassphraseAck *message,
                      ProtobufCAllocator *allocator);
/* GetEntropy methods */
void   get_entropy__init
                     (GetEntropy         *message);
size_t get_entropy__get_packed_size
                     (const GetEntropy   *message);
size_t get_entropy__pack
                     (const GetEntropy   *message,
                      uint8_t             *out);
size_t get_entropy__pack_to_buffer
                     (const GetEntropy   *message,
                      ProtobufCBuffer     *buffer);
GetEntropy *
       get_entropy__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   get_entropy__free_unpacked
                     (GetEntropy *message,
                      ProtobufCAllocator *allocator);
/* Entropy methods */
void   entropy__init
                     (Entropy         *message);
size_t entropy__get_packed_size
                     (const Entropy   *message);
size_t entropy__pack
                     (const Entropy   *message,
                      uint8_t             *out);
size_t entropy__pack_to_buffer
                     (const Entropy   *message,
                      ProtobufCBuffer     *buffer);
Entropy *
       entropy__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   entropy__free_unpacked
                     (Entropy *message,
                      ProtobufCAllocator *allocator);
/* GetPublicKey methods */
void   get_public_key__init
                     (GetPublicKey         *message);
size_t get_public_key__get_packed_size
                     (const GetPublicKey   *message);
size_t get_public_key__pack
                     (const GetPublicKey   *message,
                      uint8_t             *out);
size_t get_public_key__pack_to_buffer
                     (const GetPublicKey   *message,
                      ProtobufCBuffer     *buffer);
GetPublicKey *
       get_public_key__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   get_public_key__free_unpacked
                     (GetPublicKey *message,
                      ProtobufCAllocator *allocator);
/* PublicKey methods */
void   public_key__init
                     (PublicKey         *message);
size_t public_key__get_packed_size
                     (const PublicKey   *message);
size_t public_key__pack
                     (const PublicKey   *message,
                      uint8_t             *out);
size_t public_key__pack_to_buffer
                     (const PublicKey   *message,
                      ProtobufCBuffer     *buffer);
PublicKey *
       public_key__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   public_key__free_unpacked
                     (PublicKey *message,
                      ProtobufCAllocator *allocator);
/* GetAddress methods */
void   get_address__init
                     (GetAddress         *message);
size_t get_address__get_packed_size
                     (const GetAddress   *message);
size_t get_address__pack
                     (const GetAddress   *message,
                      uint8_t             *out);
size_t get_address__pack_to_buffer
                     (const GetAddress   *message,
                      ProtobufCBuffer     *buffer);
GetAddress *
       get_address__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   get_address__free_unpacked
                     (GetAddress *message,
                      ProtobufCAllocator *allocator);
/* EthereumGetAddress methods */
void   ethereum_get_address__init
                     (EthereumGetAddress         *message);
size_t ethereum_get_address__get_packed_size
                     (const EthereumGetAddress   *message);
size_t ethereum_get_address__pack
                     (const EthereumGetAddress   *message,
                      uint8_t             *out);
size_t ethereum_get_address__pack_to_buffer
                     (const EthereumGetAddress   *message,
                      ProtobufCBuffer     *buffer);
EthereumGetAddress *
       ethereum_get_address__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   ethereum_get_address__free_unpacked
                     (EthereumGetAddress *message,
                      ProtobufCAllocator *allocator);
/* Address methods */
void   address__init
                     (Address         *message);
size_t address__get_packed_size
                     (const Address   *message);
size_t address__pack
                     (const Address   *message,
                      uint8_t             *out);
size_t address__pack_to_buffer
                     (const Address   *message,
                      ProtobufCBuffer     *buffer);
Address *
       address__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   address__free_unpacked
                     (Address *message,
                      ProtobufCAllocator *allocator);
/* EthereumAddress methods */
void   ethereum_address__init
                     (EthereumAddress         *message);
size_t ethereum_address__get_packed_size
                     (const EthereumAddress   *message);
size_t ethereum_address__pack
                     (const EthereumAddress   *message,
                      uint8_t             *out);
size_t ethereum_address__pack_to_buffer
                     (const EthereumAddress   *message,
                      ProtobufCBuffer     *buffer);
EthereumAddress *
       ethereum_address__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   ethereum_address__free_unpacked
                     (EthereumAddress *message,
                      ProtobufCAllocator *allocator);
/* WipeDevice methods */
void   wipe_device__init
                     (WipeDevice         *message);
size_t wipe_device__get_packed_size
                     (const WipeDevice   *message);
size_t wipe_device__pack
                     (const WipeDevice   *message,
                      uint8_t             *out);
size_t wipe_device__pack_to_buffer
                     (const WipeDevice   *message,
                      ProtobufCBuffer     *buffer);
WipeDevice *
       wipe_device__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   wipe_device__free_unpacked
                     (WipeDevice *message,
                      ProtobufCAllocator *allocator);
/* LoadDevice methods */
void   load_device__init
                     (LoadDevice         *message);
size_t load_device__get_packed_size
                     (const LoadDevice   *message);
size_t load_device__pack
                     (const LoadDevice   *message,
                      uint8_t             *out);
size_t load_device__pack_to_buffer
                     (const LoadDevice   *message,
                      ProtobufCBuffer     *buffer);
LoadDevice *
       load_device__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   load_device__free_unpacked
                     (LoadDevice *message,
                      ProtobufCAllocator *allocator);
/* ResetDevice methods */
void   reset_device__init
                     (ResetDevice         *message);
size_t reset_device__get_packed_size
                     (const ResetDevice   *message);
size_t reset_device__pack
                     (const ResetDevice   *message,
                      uint8_t             *out);
size_t reset_device__pack_to_buffer
                     (const ResetDevice   *message,
                      ProtobufCBuffer     *buffer);
ResetDevice *
       reset_device__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   reset_device__free_unpacked
                     (ResetDevice *message,
                      ProtobufCAllocator *allocator);
/* EntropyRequest methods */
void   entropy_request__init
                     (EntropyRequest         *message);
size_t entropy_request__get_packed_size
                     (const EntropyRequest   *message);
size_t entropy_request__pack
                     (const EntropyRequest   *message,
                      uint8_t             *out);
size_t entropy_request__pack_to_buffer
                     (const EntropyRequest   *message,
                      ProtobufCBuffer     *buffer);
EntropyRequest *
       entropy_request__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   entropy_request__free_unpacked
                     (EntropyRequest *message,
                      ProtobufCAllocator *allocator);
/* EntropyAck methods */
void   entropy_ack__init
                     (EntropyAck         *message);
size_t entropy_ack__get_packed_size
                     (const EntropyAck   *message);
size_t entropy_ack__pack
                     (const EntropyAck   *message,
                      uint8_t             *out);
size_t entropy_ack__pack_to_buffer
                     (const EntropyAck   *message,
                      ProtobufCBuffer     *buffer);
EntropyAck *
       entropy_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   entropy_ack__free_unpacked
                     (EntropyAck *message,
                      ProtobufCAllocator *allocator);
/* RecoveryDevice methods */
void   recovery_device__init
                     (RecoveryDevice         *message);
size_t recovery_device__get_packed_size
                     (const RecoveryDevice   *message);
size_t recovery_device__pack
                     (const RecoveryDevice   *message,
                      uint8_t             *out);
size_t recovery_device__pack_to_buffer
                     (const RecoveryDevice   *message,
                      ProtobufCBuffer     *buffer);
RecoveryDevice *
       recovery_device__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   recovery_device__free_unpacked
                     (RecoveryDevice *message,
                      ProtobufCAllocator *allocator);
/* WordRequest methods */
void   word_request__init
                     (WordRequest         *message);
size_t word_request__get_packed_size
                     (const WordRequest   *message);
size_t word_request__pack
                     (const WordRequest   *message,
                      uint8_t             *out);
size_t word_request__pack_to_buffer
                     (const WordRequest   *message,
                      ProtobufCBuffer     *buffer);
WordRequest *
       word_request__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   word_request__free_unpacked
                     (WordRequest *message,
                      ProtobufCAllocator *allocator);
/* WordAck methods */
void   word_ack__init
                     (WordAck         *message);
size_t word_ack__get_packed_size
                     (const WordAck   *message);
size_t word_ack__pack
                     (const WordAck   *message,
                      uint8_t             *out);
size_t word_ack__pack_to_buffer
                     (const WordAck   *message,
                      ProtobufCBuffer     *buffer);
WordAck *
       word_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   word_ack__free_unpacked
                     (WordAck *message,
                      ProtobufCAllocator *allocator);
/* SignMessage methods */
void   sign_message__init
                     (SignMessage         *message);
size_t sign_message__get_packed_size
                     (const SignMessage   *message);
size_t sign_message__pack
                     (const SignMessage   *message,
                      uint8_t             *out);
size_t sign_message__pack_to_buffer
                     (const SignMessage   *message,
                      ProtobufCBuffer     *buffer);
SignMessage *
       sign_message__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   sign_message__free_unpacked
                     (SignMessage *message,
                      ProtobufCAllocator *allocator);
/* VerifyMessage methods */
void   verify_message__init
                     (VerifyMessage         *message);
size_t verify_message__get_packed_size
                     (const VerifyMessage   *message);
size_t verify_message__pack
                     (const VerifyMessage   *message,
                      uint8_t             *out);
size_t verify_message__pack_to_buffer
                     (const VerifyMessage   *message,
                      ProtobufCBuffer     *buffer);
VerifyMessage *
       verify_message__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   verify_message__free_unpacked
                     (VerifyMessage *message,
                      ProtobufCAllocator *allocator);
/* MessageSignature methods */
void   message_signature__init
                     (MessageSignature         *message);
size_t message_signature__get_packed_size
                     (const MessageSignature   *message);
size_t message_signature__pack
                     (const MessageSignature   *message,
                      uint8_t             *out);
size_t message_signature__pack_to_buffer
                     (const MessageSignature   *message,
                      ProtobufCBuffer     *buffer);
MessageSignature *
       message_signature__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   message_signature__free_unpacked
                     (MessageSignature *message,
                      ProtobufCAllocator *allocator);
/* EncryptMessage methods */
void   encrypt_message__init
                     (EncryptMessage         *message);
size_t encrypt_message__get_packed_size
                     (const EncryptMessage   *message);
size_t encrypt_message__pack
                     (const EncryptMessage   *message,
                      uint8_t             *out);
size_t encrypt_message__pack_to_buffer
                     (const EncryptMessage   *message,
                      ProtobufCBuffer     *buffer);
EncryptMessage *
       encrypt_message__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   encrypt_message__free_unpacked
                     (EncryptMessage *message,
                      ProtobufCAllocator *allocator);
/* EncryptedMessage methods */
void   encrypted_message__init
                     (EncryptedMessage         *message);
size_t encrypted_message__get_packed_size
                     (const EncryptedMessage   *message);
size_t encrypted_message__pack
                     (const EncryptedMessage   *message,
                      uint8_t             *out);
size_t encrypted_message__pack_to_buffer
                     (const EncryptedMessage   *message,
                      ProtobufCBuffer     *buffer);
EncryptedMessage *
       encrypted_message__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   encrypted_message__free_unpacked
                     (EncryptedMessage *message,
                      ProtobufCAllocator *allocator);
/* DecryptMessage methods */
void   decrypt_message__init
                     (DecryptMessage         *message);
size_t decrypt_message__get_packed_size
                     (const DecryptMessage   *message);
size_t decrypt_message__pack
                     (const DecryptMessage   *message,
                      uint8_t             *out);
size_t decrypt_message__pack_to_buffer
                     (const DecryptMessage   *message,
                      ProtobufCBuffer     *buffer);
DecryptMessage *
       decrypt_message__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   decrypt_message__free_unpacked
                     (DecryptMessage *message,
                      ProtobufCAllocator *allocator);
/* DecryptedMessage methods */
void   decrypted_message__init
                     (DecryptedMessage         *message);
size_t decrypted_message__get_packed_size
                     (const DecryptedMessage   *message);
size_t decrypted_message__pack
                     (const DecryptedMessage   *message,
                      uint8_t             *out);
size_t decrypted_message__pack_to_buffer
                     (const DecryptedMessage   *message,
                      ProtobufCBuffer     *buffer);
DecryptedMessage *
       decrypted_message__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   decrypted_message__free_unpacked
                     (DecryptedMessage *message,
                      ProtobufCAllocator *allocator);
/* CipherKeyValue methods */
void   cipher_key_value__init
                     (CipherKeyValue         *message);
size_t cipher_key_value__get_packed_size
                     (const CipherKeyValue   *message);
size_t cipher_key_value__pack
                     (const CipherKeyValue   *message,
                      uint8_t             *out);
size_t cipher_key_value__pack_to_buffer
                     (const CipherKeyValue   *message,
                      ProtobufCBuffer     *buffer);
CipherKeyValue *
       cipher_key_value__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cipher_key_value__free_unpacked
                     (CipherKeyValue *message,
                      ProtobufCAllocator *allocator);
/* CipheredKeyValue methods */
void   ciphered_key_value__init
                     (CipheredKeyValue         *message);
size_t ciphered_key_value__get_packed_size
                     (const CipheredKeyValue   *message);
size_t ciphered_key_value__pack
                     (const CipheredKeyValue   *message,
                      uint8_t             *out);
size_t ciphered_key_value__pack_to_buffer
                     (const CipheredKeyValue   *message,
                      ProtobufCBuffer     *buffer);
CipheredKeyValue *
       ciphered_key_value__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   ciphered_key_value__free_unpacked
                     (CipheredKeyValue *message,
                      ProtobufCAllocator *allocator);
/* EstimateTxSize methods */
void   estimate_tx_size__init
                     (EstimateTxSize         *message);
size_t estimate_tx_size__get_packed_size
                     (const EstimateTxSize   *message);
size_t estimate_tx_size__pack
                     (const EstimateTxSize   *message,
                      uint8_t             *out);
size_t estimate_tx_size__pack_to_buffer
                     (const EstimateTxSize   *message,
                      ProtobufCBuffer     *buffer);
EstimateTxSize *
       estimate_tx_size__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   estimate_tx_size__free_unpacked
                     (EstimateTxSize *message,
                      ProtobufCAllocator *allocator);
/* TxSize methods */
void   tx_size__init
                     (TxSize         *message);
size_t tx_size__get_packed_size
                     (const TxSize   *message);
size_t tx_size__pack
                     (const TxSize   *message,
                      uint8_t             *out);
size_t tx_size__pack_to_buffer
                     (const TxSize   *message,
                      ProtobufCBuffer     *buffer);
TxSize *
       tx_size__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   tx_size__free_unpacked
                     (TxSize *message,
                      ProtobufCAllocator *allocator);
/* SignTx methods */
void   sign_tx__init
                     (SignTx         *message);
size_t sign_tx__get_packed_size
                     (const SignTx   *message);
size_t sign_tx__pack
                     (const SignTx   *message,
                      uint8_t             *out);
size_t sign_tx__pack_to_buffer
                     (const SignTx   *message,
                      ProtobufCBuffer     *buffer);
SignTx *
       sign_tx__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   sign_tx__free_unpacked
                     (SignTx *message,
                      ProtobufCAllocator *allocator);
/* SimpleSignTx methods */
void   simple_sign_tx__init
                     (SimpleSignTx         *message);
size_t simple_sign_tx__get_packed_size
                     (const SimpleSignTx   *message);
size_t simple_sign_tx__pack
                     (const SimpleSignTx   *message,
                      uint8_t             *out);
size_t simple_sign_tx__pack_to_buffer
                     (const SimpleSignTx   *message,
                      ProtobufCBuffer     *buffer);
SimpleSignTx *
       simple_sign_tx__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   simple_sign_tx__free_unpacked
                     (SimpleSignTx *message,
                      ProtobufCAllocator *allocator);
/* TxRequest methods */
void   tx_request__init
                     (TxRequest         *message);
size_t tx_request__get_packed_size
                     (const TxRequest   *message);
size_t tx_request__pack
                     (const TxRequest   *message,
                      uint8_t             *out);
size_t tx_request__pack_to_buffer
                     (const TxRequest   *message,
                      ProtobufCBuffer     *buffer);
TxRequest *
       tx_request__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   tx_request__free_unpacked
                     (TxRequest *message,
                      ProtobufCAllocator *allocator);
/* TxAck methods */
void   tx_ack__init
                     (TxAck         *message);
size_t tx_ack__get_packed_size
                     (const TxAck   *message);
size_t tx_ack__pack
                     (const TxAck   *message,
                      uint8_t             *out);
size_t tx_ack__pack_to_buffer
                     (const TxAck   *message,
                      ProtobufCBuffer     *buffer);
TxAck *
       tx_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   tx_ack__free_unpacked
                     (TxAck *message,
                      ProtobufCAllocator *allocator);
/* EthereumSignTx methods */
void   ethereum_sign_tx__init
                     (EthereumSignTx         *message);
size_t ethereum_sign_tx__get_packed_size
                     (const EthereumSignTx   *message);
size_t ethereum_sign_tx__pack
                     (const EthereumSignTx   *message,
                      uint8_t             *out);
size_t ethereum_sign_tx__pack_to_buffer
                     (const EthereumSignTx   *message,
                      ProtobufCBuffer     *buffer);
EthereumSignTx *
       ethereum_sign_tx__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   ethereum_sign_tx__free_unpacked
                     (EthereumSignTx *message,
                      ProtobufCAllocator *allocator);
/* EthereumTxRequest methods */
void   ethereum_tx_request__init
                     (EthereumTxRequest         *message);
size_t ethereum_tx_request__get_packed_size
                     (const EthereumTxRequest   *message);
size_t ethereum_tx_request__pack
                     (const EthereumTxRequest   *message,
                      uint8_t             *out);
size_t ethereum_tx_request__pack_to_buffer
                     (const EthereumTxRequest   *message,
                      ProtobufCBuffer     *buffer);
EthereumTxRequest *
       ethereum_tx_request__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   ethereum_tx_request__free_unpacked
                     (EthereumTxRequest *message,
                      ProtobufCAllocator *allocator);
/* EthereumTxAck methods */
void   ethereum_tx_ack__init
                     (EthereumTxAck         *message);
size_t ethereum_tx_ack__get_packed_size
                     (const EthereumTxAck   *message);
size_t ethereum_tx_ack__pack
                     (const EthereumTxAck   *message,
                      uint8_t             *out);
size_t ethereum_tx_ack__pack_to_buffer
                     (const EthereumTxAck   *message,
                      ProtobufCBuffer     *buffer);
EthereumTxAck *
       ethereum_tx_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   ethereum_tx_ack__free_unpacked
                     (EthereumTxAck *message,
                      ProtobufCAllocator *allocator);
/* SignIdentity methods */
void   sign_identity__init
                     (SignIdentity         *message);
size_t sign_identity__get_packed_size
                     (const SignIdentity   *message);
size_t sign_identity__pack
                     (const SignIdentity   *message,
                      uint8_t             *out);
size_t sign_identity__pack_to_buffer
                     (const SignIdentity   *message,
                      ProtobufCBuffer     *buffer);
SignIdentity *
       sign_identity__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   sign_identity__free_unpacked
                     (SignIdentity *message,
                      ProtobufCAllocator *allocator);
/* SignedIdentity methods */
void   signed_identity__init
                     (SignedIdentity         *message);
size_t signed_identity__get_packed_size
                     (const SignedIdentity   *message);
size_t signed_identity__pack
                     (const SignedIdentity   *message,
                      uint8_t             *out);
size_t signed_identity__pack_to_buffer
                     (const SignedIdentity   *message,
                      ProtobufCBuffer     *buffer);
SignedIdentity *
       signed_identity__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   signed_identity__free_unpacked
                     (SignedIdentity *message,
                      ProtobufCAllocator *allocator);
/* GetECDHSessionKey methods */
void   get_ecdhsession_key__init
                     (GetECDHSessionKey         *message);
size_t get_ecdhsession_key__get_packed_size
                     (const GetECDHSessionKey   *message);
size_t get_ecdhsession_key__pack
                     (const GetECDHSessionKey   *message,
                      uint8_t             *out);
size_t get_ecdhsession_key__pack_to_buffer
                     (const GetECDHSessionKey   *message,
                      ProtobufCBuffer     *buffer);
GetECDHSessionKey *
       get_ecdhsession_key__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   get_ecdhsession_key__free_unpacked
                     (GetECDHSessionKey *message,
                      ProtobufCAllocator *allocator);
/* ECDHSessionKey methods */
void   ecdhsession_key__init
                     (ECDHSessionKey         *message);
size_t ecdhsession_key__get_packed_size
                     (const ECDHSessionKey   *message);
size_t ecdhsession_key__pack
                     (const ECDHSessionKey   *message,
                      uint8_t             *out);
size_t ecdhsession_key__pack_to_buffer
                     (const ECDHSessionKey   *message,
                      ProtobufCBuffer     *buffer);
ECDHSessionKey *
       ecdhsession_key__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   ecdhsession_key__free_unpacked
                     (ECDHSessionKey *message,
                      ProtobufCAllocator *allocator);
/* SetU2FCounter methods */
void   set_u2_fcounter__init
                     (SetU2FCounter         *message);
size_t set_u2_fcounter__get_packed_size
                     (const SetU2FCounter   *message);
size_t set_u2_fcounter__pack
                     (const SetU2FCounter   *message,
                      uint8_t             *out);
size_t set_u2_fcounter__pack_to_buffer
                     (const SetU2FCounter   *message,
                      ProtobufCBuffer     *buffer);
SetU2FCounter *
       set_u2_fcounter__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   set_u2_fcounter__free_unpacked
                     (SetU2FCounter *message,
                      ProtobufCAllocator *allocator);
/* FirmwareErase methods */
void   firmware_erase__init
                     (FirmwareErase         *message);
size_t firmware_erase__get_packed_size
                     (const FirmwareErase   *message);
size_t firmware_erase__pack
                     (const FirmwareErase   *message,
                      uint8_t             *out);
size_t firmware_erase__pack_to_buffer
                     (const FirmwareErase   *message,
                      ProtobufCBuffer     *buffer);
FirmwareErase *
       firmware_erase__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   firmware_erase__free_unpacked
                     (FirmwareErase *message,
                      ProtobufCAllocator *allocator);
/* FirmwareUpload methods */
void   firmware_upload__init
                     (FirmwareUpload         *message);
size_t firmware_upload__get_packed_size
                     (const FirmwareUpload   *message);
size_t firmware_upload__pack
                     (const FirmwareUpload   *message,
                      uint8_t             *out);
size_t firmware_upload__pack_to_buffer
                     (const FirmwareUpload   *message,
                      ProtobufCBuffer     *buffer);
FirmwareUpload *
       firmware_upload__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   firmware_upload__free_unpacked
                     (FirmwareUpload *message,
                      ProtobufCAllocator *allocator);
/* DebugLinkDecision methods */
void   debug_link_decision__init
                     (DebugLinkDecision         *message);
size_t debug_link_decision__get_packed_size
                     (const DebugLinkDecision   *message);
size_t debug_link_decision__pack
                     (const DebugLinkDecision   *message,
                      uint8_t             *out);
size_t debug_link_decision__pack_to_buffer
                     (const DebugLinkDecision   *message,
                      ProtobufCBuffer     *buffer);
DebugLinkDecision *
       debug_link_decision__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   debug_link_decision__free_unpacked
                     (DebugLinkDecision *message,
                      ProtobufCAllocator *allocator);
/* DebugLinkGetState methods */
void   debug_link_get_state__init
                     (DebugLinkGetState         *message);
size_t debug_link_get_state__get_packed_size
                     (const DebugLinkGetState   *message);
size_t debug_link_get_state__pack
                     (const DebugLinkGetState   *message,
                      uint8_t             *out);
size_t debug_link_get_state__pack_to_buffer
                     (const DebugLinkGetState   *message,
                      ProtobufCBuffer     *buffer);
DebugLinkGetState *
       debug_link_get_state__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   debug_link_get_state__free_unpacked
                     (DebugLinkGetState *message,
                      ProtobufCAllocator *allocator);
/* DebugLinkState methods */
void   debug_link_state__init
                     (DebugLinkState         *message);
size_t debug_link_state__get_packed_size
                     (const DebugLinkState   *message);
size_t debug_link_state__pack
                     (const DebugLinkState   *message,
                      uint8_t             *out);
size_t debug_link_state__pack_to_buffer
                     (const DebugLinkState   *message,
                      ProtobufCBuffer     *buffer);
DebugLinkState *
       debug_link_state__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   debug_link_state__free_unpacked
                     (DebugLinkState *message,
                      ProtobufCAllocator *allocator);
/* DebugLinkStop methods */
void   debug_link_stop__init
                     (DebugLinkStop         *message);
size_t debug_link_stop__get_packed_size
                     (const DebugLinkStop   *message);
size_t debug_link_stop__pack
                     (const DebugLinkStop   *message,
                      uint8_t             *out);
size_t debug_link_stop__pack_to_buffer
                     (const DebugLinkStop   *message,
                      ProtobufCBuffer     *buffer);
DebugLinkStop *
       debug_link_stop__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   debug_link_stop__free_unpacked
                     (DebugLinkStop *message,
                      ProtobufCAllocator *allocator);
/* DebugLinkLog methods */
void   debug_link_log__init
                     (DebugLinkLog         *message);
size_t debug_link_log__get_packed_size
                     (const DebugLinkLog   *message);
size_t debug_link_log__pack
                     (const DebugLinkLog   *message,
                      uint8_t             *out);
size_t debug_link_log__pack_to_buffer
                     (const DebugLinkLog   *message,
                      ProtobufCBuffer     *buffer);
DebugLinkLog *
       debug_link_log__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   debug_link_log__free_unpacked
                     (DebugLinkLog *message,
                      ProtobufCAllocator *allocator);
/* DebugLinkMemoryRead methods */
void   debug_link_memory_read__init
                     (DebugLinkMemoryRead         *message);
size_t debug_link_memory_read__get_packed_size
                     (const DebugLinkMemoryRead   *message);
size_t debug_link_memory_read__pack
                     (const DebugLinkMemoryRead   *message,
                      uint8_t             *out);
size_t debug_link_memory_read__pack_to_buffer
                     (const DebugLinkMemoryRead   *message,
                      ProtobufCBuffer     *buffer);
DebugLinkMemoryRead *
       debug_link_memory_read__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   debug_link_memory_read__free_unpacked
                     (DebugLinkMemoryRead *message,
                      ProtobufCAllocator *allocator);
/* DebugLinkMemory methods */
void   debug_link_memory__init
                     (DebugLinkMemory         *message);
size_t debug_link_memory__get_packed_size
                     (const DebugLinkMemory   *message);
size_t debug_link_memory__pack
                     (const DebugLinkMemory   *message,
                      uint8_t             *out);
size_t debug_link_memory__pack_to_buffer
                     (const DebugLinkMemory   *message,
                      ProtobufCBuffer     *buffer);
DebugLinkMemory *
       debug_link_memory__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   debug_link_memory__free_unpacked
                     (DebugLinkMemory *message,
                      ProtobufCAllocator *allocator);
/* DebugLinkMemoryWrite methods */
void   debug_link_memory_write__init
                     (DebugLinkMemoryWrite         *message);
size_t debug_link_memory_write__get_packed_size
                     (const DebugLinkMemoryWrite   *message);
size_t debug_link_memory_write__pack
                     (const DebugLinkMemoryWrite   *message,
                      uint8_t             *out);
size_t debug_link_memory_write__pack_to_buffer
                     (const DebugLinkMemoryWrite   *message,
                      ProtobufCBuffer     *buffer);
DebugLinkMemoryWrite *
       debug_link_memory_write__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   debug_link_memory_write__free_unpacked
                     (DebugLinkMemoryWrite *message,
                      ProtobufCAllocator *allocator);
/* DebugLinkFlashErase methods */
void   debug_link_flash_erase__init
                     (DebugLinkFlashErase         *message);
size_t debug_link_flash_erase__get_packed_size
                     (const DebugLinkFlashErase   *message);
size_t debug_link_flash_erase__pack
                     (const DebugLinkFlashErase   *message,
                      uint8_t             *out);
size_t debug_link_flash_erase__pack_to_buffer
                     (const DebugLinkFlashErase   *message,
                      ProtobufCBuffer     *buffer);
DebugLinkFlashErase *
       debug_link_flash_erase__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   debug_link_flash_erase__free_unpacked
                     (DebugLinkFlashErase *message,
                      ProtobufCAllocator *allocator);
/* XmrRequestSessionKey methods */
void   xmr_request_session_key__init
                     (XmrRequestSessionKey         *message);
size_t xmr_request_session_key__get_packed_size
                     (const XmrRequestSessionKey   *message);
size_t xmr_request_session_key__pack
                     (const XmrRequestSessionKey   *message,
                      uint8_t             *out);
size_t xmr_request_session_key__pack_to_buffer
                     (const XmrRequestSessionKey   *message,
                      ProtobufCBuffer     *buffer);
XmrRequestSessionKey *
       xmr_request_session_key__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   xmr_request_session_key__free_unpacked
                     (XmrRequestSessionKey *message,
                      ProtobufCAllocator *allocator);
/* XmrRequestSessionKeyAck methods */
void   xmr_request_session_key_ack__init
                     (XmrRequestSessionKeyAck         *message);
size_t xmr_request_session_key_ack__get_packed_size
                     (const XmrRequestSessionKeyAck   *message);
size_t xmr_request_session_key_ack__pack
                     (const XmrRequestSessionKeyAck   *message,
                      uint8_t             *out);
size_t xmr_request_session_key_ack__pack_to_buffer
                     (const XmrRequestSessionKeyAck   *message,
                      ProtobufCBuffer     *buffer);
XmrRequestSessionKeyAck *
       xmr_request_session_key_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   xmr_request_session_key_ack__free_unpacked
                     (XmrRequestSessionKeyAck *message,
                      ProtobufCAllocator *allocator);
/* XmrRequestViewKey methods */
void   xmr_request_view_key__init
                     (XmrRequestViewKey         *message);
size_t xmr_request_view_key__get_packed_size
                     (const XmrRequestViewKey   *message);
size_t xmr_request_view_key__pack
                     (const XmrRequestViewKey   *message,
                      uint8_t             *out);
size_t xmr_request_view_key__pack_to_buffer
                     (const XmrRequestViewKey   *message,
                      ProtobufCBuffer     *buffer);
XmrRequestViewKey *
       xmr_request_view_key__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   xmr_request_view_key__free_unpacked
                     (XmrRequestViewKey *message,
                      ProtobufCAllocator *allocator);
/* XmrRequestViewKeyAck methods */
void   xmr_request_view_key_ack__init
                     (XmrRequestViewKeyAck         *message);
size_t xmr_request_view_key_ack__get_packed_size
                     (const XmrRequestViewKeyAck   *message);
size_t xmr_request_view_key_ack__pack
                     (const XmrRequestViewKeyAck   *message,
                      uint8_t             *out);
size_t xmr_request_view_key_ack__pack_to_buffer
                     (const XmrRequestViewKeyAck   *message,
                      ProtobufCBuffer     *buffer);
XmrRequestViewKeyAck *
       xmr_request_view_key_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   xmr_request_view_key_ack__free_unpacked
                     (XmrRequestViewKeyAck *message,
                      ProtobufCAllocator *allocator);
/* XmrGenerateKeyImage methods */
void   xmr_generate_key_image__init
                     (XmrGenerateKeyImage         *message);
size_t xmr_generate_key_image__get_packed_size
                     (const XmrGenerateKeyImage   *message);
size_t xmr_generate_key_image__pack
                     (const XmrGenerateKeyImage   *message,
                      uint8_t             *out);
size_t xmr_generate_key_image__pack_to_buffer
                     (const XmrGenerateKeyImage   *message,
                      ProtobufCBuffer     *buffer);
XmrGenerateKeyImage *
       xmr_generate_key_image__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   xmr_generate_key_image__free_unpacked
                     (XmrGenerateKeyImage *message,
                      ProtobufCAllocator *allocator);
/* XmrGenerateKeyImageAck methods */
void   xmr_generate_key_image_ack__init
                     (XmrGenerateKeyImageAck         *message);
size_t xmr_generate_key_image_ack__get_packed_size
                     (const XmrGenerateKeyImageAck   *message);
size_t xmr_generate_key_image_ack__pack
                     (const XmrGenerateKeyImageAck   *message,
                      uint8_t             *out);
size_t xmr_generate_key_image_ack__pack_to_buffer
                     (const XmrGenerateKeyImageAck   *message,
                      ProtobufCBuffer     *buffer);
XmrGenerateKeyImageAck *
       xmr_generate_key_image_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   xmr_generate_key_image_ack__free_unpacked
                     (XmrGenerateKeyImageAck *message,
                      ProtobufCAllocator *allocator);
/* XmrGenerateSignature methods */
void   xmr_generate_signature__init
                     (XmrGenerateSignature         *message);
size_t xmr_generate_signature__get_packed_size
                     (const XmrGenerateSignature   *message);
size_t xmr_generate_signature__pack
                     (const XmrGenerateSignature   *message,
                      uint8_t             *out);
size_t xmr_generate_signature__pack_to_buffer
                     (const XmrGenerateSignature   *message,
                      ProtobufCBuffer     *buffer);
XmrGenerateSignature *
       xmr_generate_signature__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   xmr_generate_signature__free_unpacked
                     (XmrGenerateSignature *message,
                      ProtobufCAllocator *allocator);
/* XmrGenerateSignatureAck methods */
void   xmr_generate_signature_ack__init
                     (XmrGenerateSignatureAck         *message);
size_t xmr_generate_signature_ack__get_packed_size
                     (const XmrGenerateSignatureAck   *message);
size_t xmr_generate_signature_ack__pack
                     (const XmrGenerateSignatureAck   *message,
                      uint8_t             *out);
size_t xmr_generate_signature_ack__pack_to_buffer
                     (const XmrGenerateSignatureAck   *message,
                      ProtobufCBuffer     *buffer);
XmrGenerateSignatureAck *
       xmr_generate_signature_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   xmr_generate_signature_ack__free_unpacked
                     (XmrGenerateSignatureAck *message,
                      ProtobufCAllocator *allocator);
/* XmrGenerateTxInit methods */
void   xmr_generate_tx_init__init
                     (XmrGenerateTxInit         *message);
size_t xmr_generate_tx_init__get_packed_size
                     (const XmrGenerateTxInit   *message);
size_t xmr_generate_tx_init__pack
                     (const XmrGenerateTxInit   *message,
                      uint8_t             *out);
size_t xmr_generate_tx_init__pack_to_buffer
                     (const XmrGenerateTxInit   *message,
                      ProtobufCBuffer     *buffer);
XmrGenerateTxInit *
       xmr_generate_tx_init__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   xmr_generate_tx_init__free_unpacked
                     (XmrGenerateTxInit *message,
                      ProtobufCAllocator *allocator);
/* XmrGenerateTxInitAck methods */
void   xmr_generate_tx_init_ack__init
                     (XmrGenerateTxInitAck         *message);
size_t xmr_generate_tx_init_ack__get_packed_size
                     (const XmrGenerateTxInitAck   *message);
size_t xmr_generate_tx_init_ack__pack
                     (const XmrGenerateTxInitAck   *message,
                      uint8_t             *out);
size_t xmr_generate_tx_init_ack__pack_to_buffer
                     (const XmrGenerateTxInitAck   *message,
                      ProtobufCBuffer     *buffer);
XmrGenerateTxInitAck *
       xmr_generate_tx_init_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   xmr_generate_tx_init_ack__free_unpacked
                     (XmrGenerateTxInitAck *message,
                      ProtobufCAllocator *allocator);
/* XmrGenerateTxExtra methods */
void   xmr_generate_tx_extra__init
                     (XmrGenerateTxExtra         *message);
size_t xmr_generate_tx_extra__get_packed_size
                     (const XmrGenerateTxExtra   *message);
size_t xmr_generate_tx_extra__pack
                     (const XmrGenerateTxExtra   *message,
                      uint8_t             *out);
size_t xmr_generate_tx_extra__pack_to_buffer
                     (const XmrGenerateTxExtra   *message,
                      ProtobufCBuffer     *buffer);
XmrGenerateTxExtra *
       xmr_generate_tx_extra__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   xmr_generate_tx_extra__free_unpacked
                     (XmrGenerateTxExtra *message,
                      ProtobufCAllocator *allocator);
/* XmrGenerateTxExtraAck methods */
void   xmr_generate_tx_extra_ack__init
                     (XmrGenerateTxExtraAck         *message);
size_t xmr_generate_tx_extra_ack__get_packed_size
                     (const XmrGenerateTxExtraAck   *message);
size_t xmr_generate_tx_extra_ack__pack
                     (const XmrGenerateTxExtraAck   *message,
                      uint8_t             *out);
size_t xmr_generate_tx_extra_ack__pack_to_buffer
                     (const XmrGenerateTxExtraAck   *message,
                      ProtobufCBuffer     *buffer);
XmrGenerateTxExtraAck *
       xmr_generate_tx_extra_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   xmr_generate_tx_extra_ack__free_unpacked
                     (XmrGenerateTxExtraAck *message,
                      ProtobufCAllocator *allocator);
/* XmrGenerateTxVin methods */
void   xmr_generate_tx_vin__init
                     (XmrGenerateTxVin         *message);
size_t xmr_generate_tx_vin__get_packed_size
                     (const XmrGenerateTxVin   *message);
size_t xmr_generate_tx_vin__pack
                     (const XmrGenerateTxVin   *message,
                      uint8_t             *out);
size_t xmr_generate_tx_vin__pack_to_buffer
                     (const XmrGenerateTxVin   *message,
                      ProtobufCBuffer     *buffer);
XmrGenerateTxVin *
       xmr_generate_tx_vin__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   xmr_generate_tx_vin__free_unpacked
                     (XmrGenerateTxVin *message,
                      ProtobufCAllocator *allocator);
/* XmrGenerateTxVinAck methods */
void   xmr_generate_tx_vin_ack__init
                     (XmrGenerateTxVinAck         *message);
size_t xmr_generate_tx_vin_ack__get_packed_size
                     (const XmrGenerateTxVinAck   *message);
size_t xmr_generate_tx_vin_ack__pack
                     (const XmrGenerateTxVinAck   *message,
                      uint8_t             *out);
size_t xmr_generate_tx_vin_ack__pack_to_buffer
                     (const XmrGenerateTxVinAck   *message,
                      ProtobufCBuffer     *buffer);
XmrGenerateTxVinAck *
       xmr_generate_tx_vin_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   xmr_generate_tx_vin_ack__free_unpacked
                     (XmrGenerateTxVinAck *message,
                      ProtobufCAllocator *allocator);
/* XmrGenerateTxVout methods */
void   xmr_generate_tx_vout__init
                     (XmrGenerateTxVout         *message);
size_t xmr_generate_tx_vout__get_packed_size
                     (const XmrGenerateTxVout   *message);
size_t xmr_generate_tx_vout__pack
                     (const XmrGenerateTxVout   *message,
                      uint8_t             *out);
size_t xmr_generate_tx_vout__pack_to_buffer
                     (const XmrGenerateTxVout   *message,
                      ProtobufCBuffer     *buffer);
XmrGenerateTxVout *
       xmr_generate_tx_vout__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   xmr_generate_tx_vout__free_unpacked
                     (XmrGenerateTxVout *message,
                      ProtobufCAllocator *allocator);
/* XmrGenerateTxVoutAck methods */
void   xmr_generate_tx_vout_ack__init
                     (XmrGenerateTxVoutAck         *message);
size_t xmr_generate_tx_vout_ack__get_packed_size
                     (const XmrGenerateTxVoutAck   *message);
size_t xmr_generate_tx_vout_ack__pack
                     (const XmrGenerateTxVoutAck   *message,
                      uint8_t             *out);
size_t xmr_generate_tx_vout_ack__pack_to_buffer
                     (const XmrGenerateTxVoutAck   *message,
                      ProtobufCBuffer     *buffer);
XmrGenerateTxVoutAck *
       xmr_generate_tx_vout_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   xmr_generate_tx_vout_ack__free_unpacked
                     (XmrGenerateTxVoutAck *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Initialize_Closure)
                 (const Initialize *message,
                  void *closure_data);
typedef void (*GetFeatures_Closure)
                 (const GetFeatures *message,
                  void *closure_data);
typedef void (*Features_Closure)
                 (const Features *message,
                  void *closure_data);
typedef void (*ClearSession_Closure)
                 (const ClearSession *message,
                  void *closure_data);
typedef void (*ApplySettings_Closure)
                 (const ApplySettings *message,
                  void *closure_data);
typedef void (*ChangePin_Closure)
                 (const ChangePin *message,
                  void *closure_data);
typedef void (*Ping_Closure)
                 (const Ping *message,
                  void *closure_data);
typedef void (*Success_Closure)
                 (const Success *message,
                  void *closure_data);
typedef void (*Failure_Closure)
                 (const Failure *message,
                  void *closure_data);
typedef void (*ButtonRequest_Closure)
                 (const ButtonRequest *message,
                  void *closure_data);
typedef void (*ButtonAck_Closure)
                 (const ButtonAck *message,
                  void *closure_data);
typedef void (*PinMatrixRequest_Closure)
                 (const PinMatrixRequest *message,
                  void *closure_data);
typedef void (*PinMatrixAck_Closure)
                 (const PinMatrixAck *message,
                  void *closure_data);
typedef void (*Cancel_Closure)
                 (const Cancel *message,
                  void *closure_data);
typedef void (*PassphraseRequest_Closure)
                 (const PassphraseRequest *message,
                  void *closure_data);
typedef void (*PassphraseAck_Closure)
                 (const PassphraseAck *message,
                  void *closure_data);
typedef void (*GetEntropy_Closure)
                 (const GetEntropy *message,
                  void *closure_data);
typedef void (*Entropy_Closure)
                 (const Entropy *message,
                  void *closure_data);
typedef void (*GetPublicKey_Closure)
                 (const GetPublicKey *message,
                  void *closure_data);
typedef void (*PublicKey_Closure)
                 (const PublicKey *message,
                  void *closure_data);
typedef void (*GetAddress_Closure)
                 (const GetAddress *message,
                  void *closure_data);
typedef void (*EthereumGetAddress_Closure)
                 (const EthereumGetAddress *message,
                  void *closure_data);
typedef void (*Address_Closure)
                 (const Address *message,
                  void *closure_data);
typedef void (*EthereumAddress_Closure)
                 (const EthereumAddress *message,
                  void *closure_data);
typedef void (*WipeDevice_Closure)
                 (const WipeDevice *message,
                  void *closure_data);
typedef void (*LoadDevice_Closure)
                 (const LoadDevice *message,
                  void *closure_data);
typedef void (*ResetDevice_Closure)
                 (const ResetDevice *message,
                  void *closure_data);
typedef void (*EntropyRequest_Closure)
                 (const EntropyRequest *message,
                  void *closure_data);
typedef void (*EntropyAck_Closure)
                 (const EntropyAck *message,
                  void *closure_data);
typedef void (*RecoveryDevice_Closure)
                 (const RecoveryDevice *message,
                  void *closure_data);
typedef void (*WordRequest_Closure)
                 (const WordRequest *message,
                  void *closure_data);
typedef void (*WordAck_Closure)
                 (const WordAck *message,
                  void *closure_data);
typedef void (*SignMessage_Closure)
                 (const SignMessage *message,
                  void *closure_data);
typedef void (*VerifyMessage_Closure)
                 (const VerifyMessage *message,
                  void *closure_data);
typedef void (*MessageSignature_Closure)
                 (const MessageSignature *message,
                  void *closure_data);
typedef void (*EncryptMessage_Closure)
                 (const EncryptMessage *message,
                  void *closure_data);
typedef void (*EncryptedMessage_Closure)
                 (const EncryptedMessage *message,
                  void *closure_data);
typedef void (*DecryptMessage_Closure)
                 (const DecryptMessage *message,
                  void *closure_data);
typedef void (*DecryptedMessage_Closure)
                 (const DecryptedMessage *message,
                  void *closure_data);
typedef void (*CipherKeyValue_Closure)
                 (const CipherKeyValue *message,
                  void *closure_data);
typedef void (*CipheredKeyValue_Closure)
                 (const CipheredKeyValue *message,
                  void *closure_data);
typedef void (*EstimateTxSize_Closure)
                 (const EstimateTxSize *message,
                  void *closure_data);
typedef void (*TxSize_Closure)
                 (const TxSize *message,
                  void *closure_data);
typedef void (*SignTx_Closure)
                 (const SignTx *message,
                  void *closure_data);
typedef void (*SimpleSignTx_Closure)
                 (const SimpleSignTx *message,
                  void *closure_data);
typedef void (*TxRequest_Closure)
                 (const TxRequest *message,
                  void *closure_data);
typedef void (*TxAck_Closure)
                 (const TxAck *message,
                  void *closure_data);
typedef void (*EthereumSignTx_Closure)
                 (const EthereumSignTx *message,
                  void *closure_data);
typedef void (*EthereumTxRequest_Closure)
                 (const EthereumTxRequest *message,
                  void *closure_data);
typedef void (*EthereumTxAck_Closure)
                 (const EthereumTxAck *message,
                  void *closure_data);
typedef void (*SignIdentity_Closure)
                 (const SignIdentity *message,
                  void *closure_data);
typedef void (*SignedIdentity_Closure)
                 (const SignedIdentity *message,
                  void *closure_data);
typedef void (*GetECDHSessionKey_Closure)
                 (const GetECDHSessionKey *message,
                  void *closure_data);
typedef void (*ECDHSessionKey_Closure)
                 (const ECDHSessionKey *message,
                  void *closure_data);
typedef void (*SetU2FCounter_Closure)
                 (const SetU2FCounter *message,
                  void *closure_data);
typedef void (*FirmwareErase_Closure)
                 (const FirmwareErase *message,
                  void *closure_data);
typedef void (*FirmwareUpload_Closure)
                 (const FirmwareUpload *message,
                  void *closure_data);
typedef void (*DebugLinkDecision_Closure)
                 (const DebugLinkDecision *message,
                  void *closure_data);
typedef void (*DebugLinkGetState_Closure)
                 (const DebugLinkGetState *message,
                  void *closure_data);
typedef void (*DebugLinkState_Closure)
                 (const DebugLinkState *message,
                  void *closure_data);
typedef void (*DebugLinkStop_Closure)
                 (const DebugLinkStop *message,
                  void *closure_data);
typedef void (*DebugLinkLog_Closure)
                 (const DebugLinkLog *message,
                  void *closure_data);
typedef void (*DebugLinkMemoryRead_Closure)
                 (const DebugLinkMemoryRead *message,
                  void *closure_data);
typedef void (*DebugLinkMemory_Closure)
                 (const DebugLinkMemory *message,
                  void *closure_data);
typedef void (*DebugLinkMemoryWrite_Closure)
                 (const DebugLinkMemoryWrite *message,
                  void *closure_data);
typedef void (*DebugLinkFlashErase_Closure)
                 (const DebugLinkFlashErase *message,
                  void *closure_data);
typedef void (*XmrRequestSessionKey_Closure)
                 (const XmrRequestSessionKey *message,
                  void *closure_data);
typedef void (*XmrRequestSessionKeyAck_Closure)
                 (const XmrRequestSessionKeyAck *message,
                  void *closure_data);
typedef void (*XmrRequestViewKey_Closure)
                 (const XmrRequestViewKey *message,
                  void *closure_data);
typedef void (*XmrRequestViewKeyAck_Closure)
                 (const XmrRequestViewKeyAck *message,
                  void *closure_data);
typedef void (*XmrGenerateKeyImage_Closure)
                 (const XmrGenerateKeyImage *message,
                  void *closure_data);
typedef void (*XmrGenerateKeyImageAck_Closure)
                 (const XmrGenerateKeyImageAck *message,
                  void *closure_data);
typedef void (*XmrGenerateSignature_Closure)
                 (const XmrGenerateSignature *message,
                  void *closure_data);
typedef void (*XmrGenerateSignatureAck_Closure)
                 (const XmrGenerateSignatureAck *message,
                  void *closure_data);
typedef void (*XmrGenerateTxInit_Closure)
                 (const XmrGenerateTxInit *message,
                  void *closure_data);
typedef void (*XmrGenerateTxInitAck_Closure)
                 (const XmrGenerateTxInitAck *message,
                  void *closure_data);
typedef void (*XmrGenerateTxExtra_Closure)
                 (const XmrGenerateTxExtra *message,
                  void *closure_data);
typedef void (*XmrGenerateTxExtraAck_Closure)
                 (const XmrGenerateTxExtraAck *message,
                  void *closure_data);
typedef void (*XmrGenerateTxVin_Closure)
                 (const XmrGenerateTxVin *message,
                  void *closure_data);
typedef void (*XmrGenerateTxVinAck_Closure)
                 (const XmrGenerateTxVinAck *message,
                  void *closure_data);
typedef void (*XmrGenerateTxVout_Closure)
                 (const XmrGenerateTxVout *message,
                  void *closure_data);
typedef void (*XmrGenerateTxVoutAck_Closure)
                 (const XmrGenerateTxVoutAck *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCEnumDescriptor    message_type__descriptor;
extern const ProtobufCMessageDescriptor initialize__descriptor;
extern const ProtobufCMessageDescriptor get_features__descriptor;
extern const ProtobufCMessageDescriptor features__descriptor;
extern const ProtobufCMessageDescriptor clear_session__descriptor;
extern const ProtobufCMessageDescriptor apply_settings__descriptor;
extern const ProtobufCMessageDescriptor change_pin__descriptor;
extern const ProtobufCMessageDescriptor ping__descriptor;
extern const ProtobufCMessageDescriptor success__descriptor;
extern const ProtobufCMessageDescriptor failure__descriptor;
extern const ProtobufCMessageDescriptor button_request__descriptor;
extern const ProtobufCMessageDescriptor button_ack__descriptor;
extern const ProtobufCMessageDescriptor pin_matrix_request__descriptor;
extern const ProtobufCMessageDescriptor pin_matrix_ack__descriptor;
extern const ProtobufCMessageDescriptor cancel__descriptor;
extern const ProtobufCMessageDescriptor passphrase_request__descriptor;
extern const ProtobufCMessageDescriptor passphrase_ack__descriptor;
extern const ProtobufCMessageDescriptor get_entropy__descriptor;
extern const ProtobufCMessageDescriptor entropy__descriptor;
extern const ProtobufCMessageDescriptor get_public_key__descriptor;
extern const ProtobufCMessageDescriptor public_key__descriptor;
extern const ProtobufCMessageDescriptor get_address__descriptor;
extern const ProtobufCMessageDescriptor ethereum_get_address__descriptor;
extern const ProtobufCMessageDescriptor address__descriptor;
extern const ProtobufCMessageDescriptor ethereum_address__descriptor;
extern const ProtobufCMessageDescriptor wipe_device__descriptor;
extern const ProtobufCMessageDescriptor load_device__descriptor;
extern const ProtobufCMessageDescriptor reset_device__descriptor;
extern const ProtobufCMessageDescriptor entropy_request__descriptor;
extern const ProtobufCMessageDescriptor entropy_ack__descriptor;
extern const ProtobufCMessageDescriptor recovery_device__descriptor;
extern const ProtobufCMessageDescriptor word_request__descriptor;
extern const ProtobufCMessageDescriptor word_ack__descriptor;
extern const ProtobufCMessageDescriptor sign_message__descriptor;
extern const ProtobufCMessageDescriptor verify_message__descriptor;
extern const ProtobufCMessageDescriptor message_signature__descriptor;
extern const ProtobufCMessageDescriptor encrypt_message__descriptor;
extern const ProtobufCMessageDescriptor encrypted_message__descriptor;
extern const ProtobufCMessageDescriptor decrypt_message__descriptor;
extern const ProtobufCMessageDescriptor decrypted_message__descriptor;
extern const ProtobufCMessageDescriptor cipher_key_value__descriptor;
extern const ProtobufCMessageDescriptor ciphered_key_value__descriptor;
extern const ProtobufCMessageDescriptor estimate_tx_size__descriptor;
extern const ProtobufCMessageDescriptor tx_size__descriptor;
extern const ProtobufCMessageDescriptor sign_tx__descriptor;
extern const ProtobufCMessageDescriptor simple_sign_tx__descriptor;
extern const ProtobufCMessageDescriptor tx_request__descriptor;
extern const ProtobufCMessageDescriptor tx_ack__descriptor;
extern const ProtobufCMessageDescriptor ethereum_sign_tx__descriptor;
extern const ProtobufCMessageDescriptor ethereum_tx_request__descriptor;
extern const ProtobufCMessageDescriptor ethereum_tx_ack__descriptor;
extern const ProtobufCMessageDescriptor sign_identity__descriptor;
extern const ProtobufCMessageDescriptor signed_identity__descriptor;
extern const ProtobufCMessageDescriptor get_ecdhsession_key__descriptor;
extern const ProtobufCMessageDescriptor ecdhsession_key__descriptor;
extern const ProtobufCMessageDescriptor set_u2_fcounter__descriptor;
extern const ProtobufCMessageDescriptor firmware_erase__descriptor;
extern const ProtobufCMessageDescriptor firmware_upload__descriptor;
extern const ProtobufCMessageDescriptor debug_link_decision__descriptor;
extern const ProtobufCMessageDescriptor debug_link_get_state__descriptor;
extern const ProtobufCMessageDescriptor debug_link_state__descriptor;
extern const ProtobufCMessageDescriptor debug_link_stop__descriptor;
extern const ProtobufCMessageDescriptor debug_link_log__descriptor;
extern const ProtobufCMessageDescriptor debug_link_memory_read__descriptor;
extern const ProtobufCMessageDescriptor debug_link_memory__descriptor;
extern const ProtobufCMessageDescriptor debug_link_memory_write__descriptor;
extern const ProtobufCMessageDescriptor debug_link_flash_erase__descriptor;
extern const ProtobufCMessageDescriptor xmr_request_session_key__descriptor;
extern const ProtobufCMessageDescriptor xmr_request_session_key_ack__descriptor;
extern const ProtobufCMessageDescriptor xmr_request_view_key__descriptor;
extern const ProtobufCMessageDescriptor xmr_request_view_key_ack__descriptor;
extern const ProtobufCMessageDescriptor xmr_generate_key_image__descriptor;
extern const ProtobufCMessageDescriptor xmr_generate_key_image_ack__descriptor;
extern const ProtobufCMessageDescriptor xmr_generate_signature__descriptor;
extern const ProtobufCMessageDescriptor xmr_generate_signature_ack__descriptor;
extern const ProtobufCMessageDescriptor xmr_generate_tx_init__descriptor;
extern const ProtobufCMessageDescriptor xmr_generate_tx_init_ack__descriptor;
extern const ProtobufCMessageDescriptor xmr_generate_tx_extra__descriptor;
extern const ProtobufCMessageDescriptor xmr_generate_tx_extra_ack__descriptor;
extern const ProtobufCMessageDescriptor xmr_generate_tx_vin__descriptor;
extern const ProtobufCMessageDescriptor xmr_generate_tx_vin_ack__descriptor;
extern const ProtobufCMessageDescriptor xmr_generate_tx_vout__descriptor;
extern const ProtobufCMessageDescriptor xmr_generate_tx_vout_ack__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_messages_2eproto__INCLUDED */
